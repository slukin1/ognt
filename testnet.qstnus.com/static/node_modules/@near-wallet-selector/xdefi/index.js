import {
    waitFor
} from '@near-wallet-selector/core';
import {
    isMobile
} from 'is-mobile';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var redefine$1 = {
    exports: {}
};

var check = function(it) {
    return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global$7 =
    // eslint-disable-next-line no-undef
    check(typeof globalThis == 'object' && globalThis) ||
    check(typeof window == 'object' && window) ||
    check(typeof self == 'object' && self) ||
    check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
    // eslint-disable-next-line no-new-func
    Function('return this')();

var fails$3 = function(exec) {
    try {
        return !!exec();
    } catch (error) {
        return true;
    }
};

var fails$2 = fails$3;

// Thank's IE8 for his funny defineProperty
var descriptors = !fails$2(function() {
    return Object.defineProperty({}, 1, {
        get: function() {
            return 7;
        }
    })[1] != 7;
});

var objectDefineProperty = {};

var isObject$4 = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var global$6 = global$7;
var isObject$3 = isObject$4;

var document = global$6.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject$3(document) && isObject$3(document.createElement);

var documentCreateElement = function(it) {
    return EXISTS ? document.createElement(it) : {};
};

var DESCRIPTORS$2 = descriptors;
var fails$1 = fails$3;
var createElement = documentCreateElement;

// Thank's IE8 for his funny defineProperty
var ie8DomDefine = !DESCRIPTORS$2 && !fails$1(function() {
    return Object.defineProperty(createElement('div'), 'a', {
        get: function() {
            return 7;
        }
    }).a != 7;
});

var isObject$2 = isObject$4;

var anObject$3 = function(it) {
    if (!isObject$2(it)) {
        throw TypeError(String(it) + ' is not an object');
    }
    return it;
};

var isObject$1 = isObject$4;

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var toPrimitive$1 = function(input, PREFERRED_STRING) {
    if (!isObject$1(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof(fn = input.toString) == 'function' && !isObject$1(val = fn.call(input))) return val;
    if (typeof(fn = input.valueOf) == 'function' && !isObject$1(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof(fn = input.toString) == 'function' && !isObject$1(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
};

var DESCRIPTORS$1 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var anObject$2 = anObject$3;
var toPrimitive = toPrimitive$1;

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
objectDefineProperty.f = DESCRIPTORS$1 ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
    anObject$2(O);
    P = toPrimitive(P, true);
    anObject$2(Attributes);
    if (IE8_DOM_DEFINE) try {
        return nativeDefineProperty(O, P, Attributes);
    } catch (error) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
};

var createPropertyDescriptor$1 = function(bitmap, value) {
    return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
    };
};

var DESCRIPTORS = descriptors;
var definePropertyModule = objectDefineProperty;
var createPropertyDescriptor = createPropertyDescriptor$1;

var createNonEnumerableProperty$3 = DESCRIPTORS ? function(object, key, value) {
    return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
    object[key] = value;
    return object;
};

var hasOwnProperty = {}.hasOwnProperty;

var has$2 = function(it, key) {
    return hasOwnProperty.call(it, key);
};

var global$5 = global$7;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$3;

var setGlobal$2 = function(key, value) {
    try {
        createNonEnumerableProperty$2(global$5, key, value);
    } catch (error) {
        global$5[key] = value;
    }
    return value;
};

var global$4 = global$7;
var setGlobal$1 = setGlobal$2;

var SHARED = '__core-js_shared__';
var store$3 = global$4[SHARED] || setGlobal$1(SHARED, {});

var sharedStore = store$3;

var store$2 = sharedStore;

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store$2.inspectSource != 'function') {
    store$2.inspectSource = function(it) {
        return functionToString.call(it);
    };
}

var inspectSource$2 = store$2.inspectSource;

var global$3 = global$7;
var inspectSource$1 = inspectSource$2;

var WeakMap$1 = global$3.WeakMap;

var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource$1(WeakMap$1));

var shared$1 = {
    exports: {}
};

var store$1 = sharedStore;

(shared$1.exports = function(key, value) {
    return store$1[key] || (store$1[key] = value !== undefined ? value : {});
})('versions', []).push({
    version: '3.6.5',
    mode: 'global',
    copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
});

var id = 0;
var postfix = Math.random();

var uid$1 = function(key) {
    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

var shared = shared$1.exports;
var uid = uid$1;

var keys = shared('keys');

var sharedKey$1 = function(key) {
    return keys[key] || (keys[key] = uid(key));
};

var NATIVE_WEAK_MAP = nativeWeakMap;
var global$2 = global$7;
var isObject = isObject$4;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$3;
var objectHas = has$2;
var sharedKey = sharedKey$1;

var WeakMap = global$2.WeakMap;
var set, get, has$1;

var enforce = function(it) {
    return has$1(it) ? get(it) : set(it, {});
};

var getterFor = function(TYPE) {
    return function(it) {
        var state;
        if (!isObject(it) || (state = get(it)).type !== TYPE) {
            throw TypeError('Incompatible receiver, ' + TYPE + ' required');
        }
        return state;
    };
};

if (NATIVE_WEAK_MAP) {
    var store = new WeakMap();
    var wmget = store.get;
    var wmhas = store.has;
    var wmset = store.set;
    set = function(it, metadata) {
        wmset.call(store, it, metadata);
        return metadata;
    };
    get = function(it) {
        return wmget.call(store, it) || {};
    };
    has$1 = function(it) {
        return wmhas.call(store, it);
    };
} else {
    var STATE = sharedKey('state');
    set = function(it, metadata) {
        createNonEnumerableProperty$1(it, STATE, metadata);
        return metadata;
    };
    get = function(it) {
        return objectHas(it, STATE) ? it[STATE] : {};
    };
    has$1 = function(it) {
        return objectHas(it, STATE);
    };
}

var internalState = {
    set: set,
    get: get,
    has: has$1,
    enforce: enforce,
    getterFor: getterFor
};

var global$1 = global$7;
var createNonEnumerableProperty = createNonEnumerableProperty$3;
var has = has$2;
var setGlobal = setGlobal$2;
var inspectSource = inspectSource$2;
var InternalStateModule = internalState;

var getInternalState = InternalStateModule.get;
var enforceInternalState = InternalStateModule.enforce;
var TEMPLATE = String(String).split('String');

(redefine$1.exports = function(O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    if (typeof value == 'function') {
        if (typeof key == 'string' && !has(value, 'name')) createNonEnumerableProperty(value, 'name', key);
        enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
    if (O === global$1) {
        if (simple) O[key] = value;
        else setGlobal(key, value);
        return;
    } else if (!unsafe) {
        delete O[key];
    } else if (!noTargetGet && O[key]) {
        simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty(O, key, value);
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState(this).source || inspectSource(this);
});

var anObject$1 = anObject$3;

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
var regexpFlags = function() {
    var that = anObject$1(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.dotAll) result += 's';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
};

var redefine = redefine$1.exports;
var anObject = anObject$3;
var fails = fails$3;
var flags = regexpFlags;

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails(function() {
    return nativeToString.call({
        source: 'a',
        flags: 'b'
    }) != '/a/b';
});
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
    redefine(RegExp.prototype, TO_STRING, function toString() {
        var R = anObject(this);
        var p = String(R.source);
        var rf = R.flags;
        var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
        return '/' + p + '/' + f;
    }, {
        unsafe: true
    });
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new(P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }

        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }

        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var icon = `data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzAiIGhlaWdodD0iYXV0byIgdmlld0JveD0iMCAwIDI0IDI0IiBmaWxsPSJub25lIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciPgo8cGF0aCBkPSJNMTQuMjYyNyAxMy40MDEzQzEyLjQyMjcgMTQuNTMwNyA5Ljk1OTg3IDE1LjExMjQgNy40NjU1OCAxNC45ODgxQzUuMzY4NDQgMTQuODg2NSAzLjY0ODQ0IDE0LjE0MTEgMi42MDg0NCAxMi45MTU3QzEuNjk0MTYgMTEuODIwMSAxLjMzOTg3IDEwLjM3NDUgMS41Nzk4NyA4LjcxMTQzQzEuNjYxMjEgOC4xNTg3NCAxLjgyNzkxIDcuNjIxNjYgMi4wNzQxNSA3LjExODk2TDIuMTA4NDQgNy4wNDgzN0MyLjk3MTcgNS40MDU5NSA0LjI1MjgyIDQuMDEzOTcgNS44MjU3MyAzLjAwOTQyQzcuMzk4NjQgMi4wMDQ4NiA5LjIwOTEzIDEuNDIyMzYgMTEuMDc5IDEuMzE5MjRDMTIuOTQ4OSAxLjIxNjExIDE0LjgxMzcgMS41OTU5MiAxNi40OSAyLjQyMTI4QzE4LjE2NjIgMy4yNDY2NSAxOS41OTYxIDQuNDg5MTIgMjAuNjM4OSA2LjAyNjQxQzIxLjY4MTcgNy41NjM3MSAyMi4zMDE1IDkuMzQyODUgMjIuNDM3MyAxMS4xODg3QzIyLjU3MzEgMTMuMDM0NiAyMi4yMjAyIDE0Ljg4MzYgMjEuNDEzMyAxNi41NTM4QzIwLjYwNjQgMTguMjI0IDE5LjM3MzQgMTkuNjU3NyAxNy44MzU1IDIwLjcxNEMxNi4yOTc3IDIxLjc3MDIgMTQuNTA4IDIyLjQxMjYgMTIuNjQyNyAyMi41Nzc4TDEyLjc1NyAyMy44NzM4QzE0Ljg1MTMgMjMuNjg5NCAxNi44NjA4IDIyLjk2OTEgMTguNTg3NyAyMS43ODM3QzIwLjMxNDYgMjAuNTk4NCAyMS42OTkyIDE4Ljk4ODkgMjIuNjA1MSAxNy4xMTM4QzIzLjUxMSAxNS4yMzg3IDIzLjkwNyAxMy4xNjI3IDIzLjc1NDEgMTEuMDkwNEMyMy42MDExIDkuMDE4MDggMjIuOTA0NSA3LjAyMDg4IDIxLjczMjggNS4yOTU1NUMyMC41NjEyIDMuNTcwMjIgMTguOTU0OSAyLjE3NjMgMTcuMDcyMyAxLjI1MTExQzE1LjE4OTYgMC4zMjU5MDkgMTMuMDk1NiAtMC4wOTg2NDExIDEwLjk5NjQgMC4wMTkyNzg3QzguODk3MjIgMC4xMzcxOTggNi44NjUzMyAwLjc5MzUyIDUuMTAwOTEgMS45MjM1OUMzLjMzNjQ5IDMuMDUzNjUgMS45MDA0MiA0LjYxODQ4IDAuOTM0MTU3IDYuNDYzOUwwLjg4ODQ0MSA2LjU1NzA3QzAuNTgyOTc2IDcuMTgwOSAwLjM3Njc0IDcuODQ3NTYgMC4yNzcwMTMgOC41MzM1NEMtMC4wMDg3MDEzMiAxMC41NjA4IDAuNDM0MTUzIDEyLjM2NTEgMS41OTEzIDEzLjc1NDJDMi44NTcwMSAxNS4yNzMzIDQuOTE3MDEgMTYuMTc2OCA3LjM4ODQ0IDE2LjI5NTRDMTAuMzk3IDE2LjQ0NTEgMTMuMzg4NCAxNS42MzQ3IDE1LjUxMTMgMTQuMTQzOUwxNC4yNjI3IDEzLjQwMTNaIiBmaWxsPSIjMjA0MUUwIj48L3BhdGg+PHBhdGggZD0iTTE2Ljc4IDE0Ljg3NUMxNS41ODI5IDE1LjkwMjggMTIuOCAxNy43NjYzIDguMTgyODYgMTguMDIwNEMzLjAxNDI5IDE4LjMwMjggMC44NjAwMDEgMTYuNjQyNSAwLjg0MDAwMSAxNi42MjU2TDAuNDIyODU2IDE3LjEzMzhMMC44NDI4NTYgMTYuNjM0MUwwIDE3LjYzMzZDMC4wOTE0Mjg2IDE3LjcwOTggMi4xNTcxNCAxOS4zNTg4IDcuMDA4NTcgMTkuMzU4OEM3LjQwNTcxIDE5LjM1ODggNy44MjI4NiAxOS4zNTg4IDguMjU3MTQgMTkuMzI0OUMxMy44MzcxIDE5LjAxNzEgMTYuOTAyOSAxNi42MTE1IDE3Ljk3MTQgMTUuNTgzN0wxNi43OCAxNC44NzVaIiBmaWxsPSIjMjA0MUUwIj48L3BhdGg+PHBhdGggZD0iTTE5LjAxOTkgMTYuMjE5MUMxOC4zMTIgMTcuMTM4NiAxNy40NDA3IDE3LjkyMzIgMTYuNDQ4NSAxOC41MzQ0QzEyLjk1MTMgMjAuNzY0OSA4LjUwMjc1IDIxLjA1MjkgNS4zODg0NyAyMC44OTc2TDUuMzIyNzUgMjIuMTk5M0M1Ljg0NTYxIDIyLjIyNDcgNi4zNDg0NyAyMi4yMzYgNi44MzcwNCAyMi4yMzZDMTUuNjE5OSAyMi4yMzYgMTkuMTY4NSAxOC4yODMxIDIwLjE1OTkgMTYuODcxM0wxOS4wMTcgMTYuMjA3OCIgZmlsbD0iIzIwNDFFMCI+PC9wYXRoPjxwYXRoIGQ9Ik0xOC42ODU2IDExLjI5MjNDMTkuMjY3OSAxMS4yOTIzIDE5LjczOTkgMTAuODI1OCAxOS43Mzk5IDEwLjI1MDRDMTkuNzM5OSA5LjY3NDk2IDE5LjI2NzkgOS4yMDg1IDE4LjY4NTYgOS4yMDg1QzE4LjEwMzQgOS4yMDg1IDE3LjYzMTMgOS42NzQ5NiAxNy42MzEzIDEwLjI1MDRDMTcuNjMxMyAxMC44MjU4IDE4LjEwMzQgMTEuMjkyMyAxOC42ODU2IDExLjI5MjNaIiBmaWxsPSIjMjA0MUUwIj48L3BhdGg+Cjwvc3ZnPgo=`;

const setupXDEFIState = (store, network) => __awaiter(void 0, void 0, void 0, function*() {
    const {
        selectedWalletId
    } = store.getState();
    const wallet = window.xfi.near;
    // Attempt to reconnect wallet if previously selected.
    if (selectedWalletId === "xdefi") {
        yield wallet.connect(network.networkId).catch(() => null);
    }
    return {
        wallet,
        network
    };
});
const isInstalled = () => {
    return waitFor(() => {
        var _a;
        return !!((_a = window.xfi) === null || _a === void 0 ? void 0 : _a.near);
    }).catch(() => false);
};
const XDEFI = ({
    metadata,
    store,
    logger,
    options
}) => __awaiter(void 0, void 0, void 0, function*() {
    const _state = yield setupXDEFIState(store, options.network);
    const getAccounts = () => {
        if (!_state.wallet.accounts) {
            return [];
        }
        return _state.wallet.accounts;
    };
    const transformTransactions = transactions => {
        const accounts = getAccounts();
        const {
            contract
        } = store.getState();
        if (!accounts.length || !contract) {
            throw new Error("Wallet not signed in");
        }
        return transactions.map(transaction => {
            return {
                signerId: transaction.signerId || accounts[0].accountId,
                receiverId: transaction.receiverId || contract.contractId,
                actions: transaction.actions
            };
        });
    };
    return {
        signIn() {
            return __awaiter(this, void 0, void 0, function*() {
                const existingAccounts = getAccounts().map(x => ({
                    accountId: x.accountId,
                    publicKey: x.publicKey.toString()
                }));
                if (existingAccounts.length) {
                    return existingAccounts;
                }
                yield _state.wallet.connect(_state.network.networkId);
                return getAccounts().map(x => ({
                    accountId: x.accountId,
                    publicKey: x.publicKey.toString()
                }));
            });
        },
        signOut() {
            return __awaiter(this, void 0, void 0, function*() {
                yield _state.wallet.disconnect();
            });
        },
        getAccounts() {
            return __awaiter(this, void 0, void 0, function*() {
                return getAccounts().map(x => ({
                    accountId: x.accountId,
                    publicKey: x.publicKey.toString()
                }));
            });
        },
        verifyOwner({
            message
        }) {
            return __awaiter(this, void 0, void 0, function*() {
                logger.log("XDEFI:verifyOwner", {
                    message
                });
                throw new Error(`Method not supported by ${metadata.name}`);
            });
        },
        signAndSendTransaction(transaction) {
            return __awaiter(this, void 0, void 0, function*() {
                logger.log("signAndSendTransaction", transaction);
                const {
                    contract
                } = store.getState();
                const accounts = getAccounts();
                if (!accounts.length || !contract) {
                    throw new Error("Wallet not signed in");
                }
                const result = yield _state.wallet.signAndSendTransaction(transformTransactions([transaction])[0]);
                return result;
            });
        },
        signAndSendTransactions({
            transactions
        }) {
            return __awaiter(this, void 0, void 0, function*() {
                logger.log("signAndSendTransactions", {
                    transactions
                });
                const result = yield _state.wallet.signAndSendTransactions(transformTransactions(transactions));
                return result;
            });
        }
    };
});

function setupXDEFI({
    iconUrl = icon,
    deprecated = false
} = {}) {
    return () => __awaiter(this, void 0, void 0, function*() {
        const mobile = isMobile();
        if (mobile) {
            return null;
        }
        const installed = yield isInstalled();
        return {
            id: "xdefi",
            type: "injected",
            metadata: {
                name: "XDEFI Wallet",
                description: "One wallet for all your Crypto",
                iconUrl,
                downloadUrl: "https://www.xdefi.io",
                deprecated,
                available: installed
            },
            init: XDEFI
        };
    });
}

export {
    setupXDEFI
};