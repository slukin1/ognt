import {
    isMobile
} from 'is-mobile';
import {
    waitFor
} from '@near-wallet-selector/core';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var check = function(it) {
    return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global$h =
    // eslint-disable-next-line no-undef
    check(typeof globalThis == 'object' && globalThis) ||
    check(typeof window == 'object' && window) ||
    check(typeof self == 'object' && self) ||
    check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
    // eslint-disable-next-line no-new-func
    Function('return this')();

var objectGetOwnPropertyDescriptor = {};

var fails$6 = function(exec) {
    try {
        return !!exec();
    } catch (error) {
        return true;
    }
};

var fails$5 = fails$6;

// Thank's IE8 for his funny defineProperty
var descriptors = !fails$5(function() {
    return Object.defineProperty({}, 1, {
        get: function() {
            return 7;
        }
    })[1] != 7;
});

var objectPropertyIsEnumerable = {};

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor$2 && !nativePropertyIsEnumerable.call({
    1: 2
}, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor$2(this, V);
    return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

var createPropertyDescriptor$2 = function(bitmap, value) {
    return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
    };
};

var toString = {}.toString;

var classofRaw$1 = function(it) {
    return toString.call(it).slice(8, -1);
};

var fails$4 = fails$6;
var classof$5 = classofRaw$1;

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails$4(function() {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins
    return !Object('z').propertyIsEnumerable(0);
}) ? function(it) {
    return classof$5(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible$1 = function(it) {
    if (it == undefined) throw TypeError("Can't call method on " + it);
    return it;
};

// toObject with fallback for non-array-like ES3 strings
var IndexedObject = indexedObject;
var requireObjectCoercible = requireObjectCoercible$1;

var toIndexedObject$3 = function(it) {
    return IndexedObject(requireObjectCoercible(it));
};

var isObject$6 = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var isObject$5 = isObject$6;

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var toPrimitive$2 = function(input, PREFERRED_STRING) {
    if (!isObject$5(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof(fn = input.toString) == 'function' && !isObject$5(val = fn.call(input))) return val;
    if (typeof(fn = input.valueOf) == 'function' && !isObject$5(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof(fn = input.toString) == 'function' && !isObject$5(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
};

var hasOwnProperty = {}.hasOwnProperty;

var has$7 = function(it, key) {
    return hasOwnProperty.call(it, key);
};

var global$g = global$h;
var isObject$4 = isObject$6;

var document$2 = global$g.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject$4(document$2) && isObject$4(document$2.createElement);

var documentCreateElement = function(it) {
    return EXISTS ? document$2.createElement(it) : {};
};

var DESCRIPTORS$4 = descriptors;
var fails$3 = fails$6;
var createElement$1 = documentCreateElement;

// Thank's IE8 for his funny defineProperty
var ie8DomDefine = !DESCRIPTORS$4 && !fails$3(function() {
    return Object.defineProperty(createElement$1('div'), 'a', {
        get: function() {
            return 7;
        }
    }).a != 7;
});

var DESCRIPTORS$3 = descriptors;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var createPropertyDescriptor$1 = createPropertyDescriptor$2;
var toIndexedObject$2 = toIndexedObject$3;
var toPrimitive$1 = toPrimitive$2;
var has$6 = has$7;
var IE8_DOM_DEFINE$1 = ie8DomDefine;

var nativeGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$3 ? nativeGetOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject$2(O);
    P = toPrimitive$1(P, true);
    if (IE8_DOM_DEFINE$1) try {
        return nativeGetOwnPropertyDescriptor(O, P);
    } catch (error) { /* empty */ }
    if (has$6(O, P)) return createPropertyDescriptor$1(!propertyIsEnumerableModule.f.call(O, P), O[P]);
};

var objectDefineProperty = {};

var isObject$3 = isObject$6;

var anObject$6 = function(it) {
    if (!isObject$3(it)) {
        throw TypeError(String(it) + ' is not an object');
    }
    return it;
};

var DESCRIPTORS$2 = descriptors;
var IE8_DOM_DEFINE = ie8DomDefine;
var anObject$5 = anObject$6;
var toPrimitive = toPrimitive$2;

var nativeDefineProperty = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
objectDefineProperty.f = DESCRIPTORS$2 ? nativeDefineProperty : function defineProperty(O, P, Attributes) {
    anObject$5(O);
    P = toPrimitive(P, true);
    anObject$5(Attributes);
    if (IE8_DOM_DEFINE) try {
        return nativeDefineProperty(O, P, Attributes);
    } catch (error) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
};

var DESCRIPTORS$1 = descriptors;
var definePropertyModule$2 = objectDefineProperty;
var createPropertyDescriptor = createPropertyDescriptor$2;

var createNonEnumerableProperty$4 = DESCRIPTORS$1 ? function(object, key, value) {
    return definePropertyModule$2.f(object, key, createPropertyDescriptor(1, value));
} : function(object, key, value) {
    object[key] = value;
    return object;
};

var redefine$3 = {
    exports: {}
};

var global$f = global$h;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$4;

var setGlobal$3 = function(key, value) {
    try {
        createNonEnumerableProperty$3(global$f, key, value);
    } catch (error) {
        global$f[key] = value;
    }
    return value;
};

var global$e = global$h;
var setGlobal$2 = setGlobal$3;

var SHARED = '__core-js_shared__';
var store$3 = global$e[SHARED] || setGlobal$2(SHARED, {});

var sharedStore = store$3;

var store$2 = sharedStore;

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store$2.inspectSource != 'function') {
    store$2.inspectSource = function(it) {
        return functionToString.call(it);
    };
}

var inspectSource$3 = store$2.inspectSource;

var global$d = global$h;
var inspectSource$2 = inspectSource$3;

var WeakMap$1 = global$d.WeakMap;

var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource$2(WeakMap$1));

var shared$2 = {
    exports: {}
};

var store$1 = sharedStore;

(shared$2.exports = function(key, value) {
    return store$1[key] || (store$1[key] = value !== undefined ? value : {});
})('versions', []).push({
    version: '3.6.5',
    mode: 'global',
    copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
});

var id$1 = 0;
var postfix = Math.random();

var uid$2 = function(key) {
    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id$1 + postfix).toString(36);
};

var shared$1 = shared$2.exports;
var uid$1 = uid$2;

var keys = shared$1('keys');

var sharedKey$1 = function(key) {
    return keys[key] || (keys[key] = uid$1(key));
};

var hiddenKeys$3 = {};

var NATIVE_WEAK_MAP = nativeWeakMap;
var global$c = global$h;
var isObject$2 = isObject$6;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$4;
var objectHas = has$7;
var sharedKey = sharedKey$1;
var hiddenKeys$2 = hiddenKeys$3;

var WeakMap = global$c.WeakMap;
var set$1, get, has$5;

var enforce = function(it) {
    return has$5(it) ? get(it) : set$1(it, {});
};

var getterFor = function(TYPE) {
    return function(it) {
        var state;
        if (!isObject$2(it) || (state = get(it)).type !== TYPE) {
            throw TypeError('Incompatible receiver, ' + TYPE + ' required');
        }
        return state;
    };
};

if (NATIVE_WEAK_MAP) {
    var store = new WeakMap();
    var wmget = store.get;
    var wmhas = store.has;
    var wmset = store.set;
    set$1 = function(it, metadata) {
        wmset.call(store, it, metadata);
        return metadata;
    };
    get = function(it) {
        return wmget.call(store, it) || {};
    };
    has$5 = function(it) {
        return wmhas.call(store, it);
    };
} else {
    var STATE = sharedKey('state');
    hiddenKeys$2[STATE] = true;
    set$1 = function(it, metadata) {
        createNonEnumerableProperty$2(it, STATE, metadata);
        return metadata;
    };
    get = function(it) {
        return objectHas(it, STATE) ? it[STATE] : {};
    };
    has$5 = function(it) {
        return objectHas(it, STATE);
    };
}

var internalState = {
    set: set$1,
    get: get,
    has: has$5,
    enforce: enforce,
    getterFor: getterFor
};

var global$b = global$h;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$4;
var has$4 = has$7;
var setGlobal$1 = setGlobal$3;
var inspectSource$1 = inspectSource$3;
var InternalStateModule$1 = internalState;

var getInternalState$1 = InternalStateModule$1.get;
var enforceInternalState = InternalStateModule$1.enforce;
var TEMPLATE = String(String).split('String');

(redefine$3.exports = function(O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    if (typeof value == 'function') {
        if (typeof key == 'string' && !has$4(value, 'name')) createNonEnumerableProperty$1(value, 'name', key);
        enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
    if (O === global$b) {
        if (simple) O[key] = value;
        else setGlobal$1(key, value);
        return;
    } else if (!unsafe) {
        delete O[key];
    } else if (!noTargetGet && O[key]) {
        simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty$1(O, key, value);
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState$1(this).source || inspectSource$1(this);
});

var global$a = global$h;

var path$1 = global$a;

var path = path$1;
var global$9 = global$h;

var aFunction$5 = function(variable) {
    return typeof variable == 'function' ? variable : undefined;
};

var getBuiltIn$5 = function(namespace, method) {
    return arguments.length < 2 ? aFunction$5(path[namespace]) || aFunction$5(global$9[namespace]) :
        path[namespace] && path[namespace][method] || global$9[namespace] && global$9[namespace][method];
};

var objectGetOwnPropertyNames = {};

var ceil = Math.ceil;
var floor = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
var toInteger$2 = function(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor : ceil)(argument);
};

var toInteger$1 = toInteger$2;

var min$1 = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
var toLength$2 = function(argument) {
    return argument > 0 ? min$1(toInteger$1(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var toInteger = toInteger$2;

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex$1 = function(index, length) {
    var integer = toInteger(index);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

var toIndexedObject$1 = toIndexedObject$3;
var toLength$1 = toLength$2;
var toAbsoluteIndex = toAbsoluteIndex$1;

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
        var O = toIndexedObject$1($this);
        var length = toLength$1(O.length);
        var index = toAbsoluteIndex(fromIndex, length);
        var value;
        // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare
        if (IS_INCLUDES && el != el)
            while (length > index) {
                value = O[index++];
                // eslint-disable-next-line no-self-compare
                if (value != value) return true;
                // Array#indexOf ignores holes, Array#includes - not
            } else
                for (; length > index; index++) {
                    if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
                }
        return !IS_INCLUDES && -1;
    };
};

var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod(false)
};

var has$3 = has$7;
var toIndexedObject = toIndexedObject$3;
var indexOf = arrayIncludes.indexOf;
var hiddenKeys$1 = hiddenKeys$3;

var objectKeysInternal = function(object, names) {
    var O = toIndexedObject(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !has$3(hiddenKeys$1, key) && has$3(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i)
        if (has$3(O, key = names[i++])) {
            ~indexOf(result, key) || result.push(key);
        }
    return result;
};

// IE8- don't enum bug keys
var enumBugKeys$1 = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
];

var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$1;

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys);
};

var objectGetOwnPropertySymbols = {};

objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

var getBuiltIn$4 = getBuiltIn$5;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var anObject$4 = anObject$6;

// all object keys, includes non-enumerable and symbols
var ownKeys$1 = getBuiltIn$4('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = getOwnPropertyNamesModule.f(anObject$4(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

var has$2 = has$7;
var ownKeys = ownKeys$1;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var definePropertyModule$1 = objectDefineProperty;

var copyConstructorProperties$1 = function(target, source) {
    var keys = ownKeys(source);
    var defineProperty = definePropertyModule$1.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!has$2(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
};

var fails$2 = fails$6;

var replacement = /#|\.prototype\./;

var isForced$2 = function(feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true :
        value == NATIVE ? false :
        typeof detection == 'function' ? fails$2(detection) :
        !!detection;
};

var normalize = isForced$2.normalize = function(string) {
    return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced$2.data = {};
var NATIVE = isForced$2.NATIVE = 'N';
var POLYFILL = isForced$2.POLYFILL = 'P';

var isForced_1 = isForced$2;

var global$8 = global$h;
var getOwnPropertyDescriptor$1 = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty = createNonEnumerableProperty$4;
var redefine$2 = redefine$3.exports;
var setGlobal = setGlobal$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced$1 = isForced_1;

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
var _export = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
        target = global$8;
    } else if (STATIC) {
        target = global$8[TARGET] || setGlobal(TARGET, {});
    } else {
        target = (global$8[TARGET] || {}).prototype;
    }
    if (target)
        for (key in source) {
            sourceProperty = source[key];
            if (options.noTargetGet) {
                descriptor = getOwnPropertyDescriptor$1(target, key);
                targetProperty = descriptor && descriptor.value;
            } else targetProperty = target[key];
            FORCED = isForced$1(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
            // contained in target
            if (!FORCED && targetProperty !== undefined) {
                if (typeof sourceProperty === typeof targetProperty) continue;
                copyConstructorProperties(sourceProperty, targetProperty);
            }
            // add a flag to not completely full polyfills
            if (options.sham || (targetProperty && targetProperty.sham)) {
                createNonEnumerableProperty(sourceProperty, 'sham', true);
            }
            // extend global
            redefine$2(target, key, sourceProperty, options);
        }
};

var global$7 = global$h;

var nativePromiseConstructor = global$7.Promise;

var redefine$1 = redefine$3.exports;

var redefineAll$1 = function(target, src, options) {
    for (var key in src) redefine$1(target, key, src[key], options);
    return target;
};

var fails$1 = fails$6;

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$1(function() {
    // Chrome 38 Symbol has incorrect toString conversion
    // eslint-disable-next-line no-undef
    return !String(Symbol());
});

var NATIVE_SYMBOL$1 = nativeSymbol;

var useSymbolAsUid = NATIVE_SYMBOL$1
    // eslint-disable-next-line no-undef
    &&
    !Symbol.sham
    // eslint-disable-next-line no-undef
    &&
    typeof Symbol.iterator == 'symbol';

var global$6 = global$h;
var shared = shared$2.exports;
var has$1 = has$7;
var uid = uid$2;
var NATIVE_SYMBOL = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;

var WellKnownSymbolsStore = shared('wks');
var Symbol$1 = global$6.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid;

var wellKnownSymbol$9 = function(name) {
    if (!has$1(WellKnownSymbolsStore, name)) {
        if (NATIVE_SYMBOL && has$1(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
        else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
    return WellKnownSymbolsStore[name];
};

var defineProperty = objectDefineProperty.f;
var has = has$7;
var wellKnownSymbol$8 = wellKnownSymbol$9;

var TO_STRING_TAG$2 = wellKnownSymbol$8('toStringTag');

var setToStringTag$1 = function(it, TAG, STATIC) {
    if (it && !has(it = STATIC ? it : it.prototype, TO_STRING_TAG$2)) {
        defineProperty(it, TO_STRING_TAG$2, {
            configurable: true,
            value: TAG
        });
    }
};

var getBuiltIn$3 = getBuiltIn$5;
var definePropertyModule = objectDefineProperty;
var wellKnownSymbol$7 = wellKnownSymbol$9;
var DESCRIPTORS = descriptors;

var SPECIES$2 = wellKnownSymbol$7('species');

var setSpecies$1 = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn$3(CONSTRUCTOR_NAME);
    var defineProperty = definePropertyModule.f;

    if (DESCRIPTORS && Constructor && !Constructor[SPECIES$2]) {
        defineProperty(Constructor, SPECIES$2, {
            configurable: true,
            get: function() {
                return this;
            }
        });
    }
};

var aFunction$4 = function(it) {
    if (typeof it != 'function') {
        throw TypeError(String(it) + ' is not a function');
    }
    return it;
};

var anInstance$1 = function(it, Constructor, name) {
    if (!(it instanceof Constructor)) {
        throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
    }
    return it;
};

var iterate$2 = {
    exports: {}
};

var iterators = {};

var wellKnownSymbol$6 = wellKnownSymbol$9;
var Iterators$1 = iterators;

var ITERATOR$2 = wellKnownSymbol$6('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
var isArrayIteratorMethod$1 = function(it) {
    return it !== undefined && (Iterators$1.Array === it || ArrayPrototype[ITERATOR$2] === it);
};

var aFunction$3 = aFunction$4;

// optional / simple context binding
var functionBindContext = function(fn, that, length) {
    aFunction$3(fn);
    if (that === undefined) return fn;
    switch (length) {
        case 0:
            return function() {
                return fn.call(that);
            };
        case 1:
            return function(a) {
                return fn.call(that, a);
            };
        case 2:
            return function(a, b) {
                return fn.call(that, a, b);
            };
        case 3:
            return function(a, b, c) {
                return fn.call(that, a, b, c);
            };
    }
    return function( /* ...args */ ) {
        return fn.apply(that, arguments);
    };
};

var wellKnownSymbol$5 = wellKnownSymbol$9;

var TO_STRING_TAG$1 = wellKnownSymbol$5('toStringTag');
var test = {};

test[TO_STRING_TAG$1] = 'z';

var toStringTagSupport = String(test) === '[object z]';

var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var classofRaw = classofRaw$1;
var wellKnownSymbol$4 = wellKnownSymbol$9;

var TO_STRING_TAG = wellKnownSymbol$4('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function() {
    return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key) {
    try {
        return it[key];
    } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
var classof$4 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
        // @@toStringTag case
        :
        typeof(tag = tryGet(O = Object(it), TO_STRING_TAG)) == 'string' ? tag
        // builtinTag case
        :
        CORRECT_ARGUMENTS ? classofRaw(O)
        // ES3 arguments fallback
        :
        (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

var classof$3 = classof$4;
var Iterators = iterators;
var wellKnownSymbol$3 = wellKnownSymbol$9;

var ITERATOR$1 = wellKnownSymbol$3('iterator');

var getIteratorMethod$1 = function(it) {
    if (it != undefined) return it[ITERATOR$1] ||
        it['@@iterator'] ||
        Iterators[classof$3(it)];
};

var anObject$3 = anObject$6;

// call something on iterator step with safe closing on error
var callWithSafeIterationClosing$1 = function(iterator, fn, value, ENTRIES) {
    try {
        return ENTRIES ? fn(anObject$3(value)[0], value[1]) : fn(value);
        // 7.4.6 IteratorClose(iterator, completion)
    } catch (error) {
        var returnMethod = iterator['return'];
        if (returnMethod !== undefined) anObject$3(returnMethod.call(iterator));
        throw error;
    }
};

var anObject$2 = anObject$6;
var isArrayIteratorMethod = isArrayIteratorMethod$1;
var toLength = toLength$2;
var bind$2 = functionBindContext;
var getIteratorMethod = getIteratorMethod$1;
var callWithSafeIterationClosing = callWithSafeIterationClosing$1;

var Result = function(stopped, result) {
    this.stopped = stopped;
    this.result = result;
};

var iterate$1 = iterate$2.exports = function(iterable, fn, that, AS_ENTRIES, IS_ITERATOR) {
    var boundFunction = bind$2(fn, that, AS_ENTRIES ? 2 : 1);
    var iterator, iterFn, index, length, result, next, step;

    if (IS_ITERATOR) {
        iterator = iterable;
    } else {
        iterFn = getIteratorMethod(iterable);
        if (typeof iterFn != 'function') throw TypeError('Target is not iterable');
        // optimisation for array iterators
        if (isArrayIteratorMethod(iterFn)) {
            for (index = 0, length = toLength(iterable.length); length > index; index++) {
                result = AS_ENTRIES ?
                    boundFunction(anObject$2(step = iterable[index])[0], step[1]) :
                    boundFunction(iterable[index]);
                if (result && result instanceof Result) return result;
            }
            return new Result(false);
        }
        iterator = iterFn.call(iterable);
    }

    next = iterator.next;
    while (!(step = next.call(iterator)).done) {
        result = callWithSafeIterationClosing(iterator, boundFunction, step.value, AS_ENTRIES);
        if (typeof result == 'object' && result && result instanceof Result) return result;
    }
    return new Result(false);
};

iterate$1.stop = function(result) {
    return new Result(true, result);
};

var wellKnownSymbol$2 = wellKnownSymbol$9;

var ITERATOR = wellKnownSymbol$2('iterator');
var SAFE_CLOSING = false;

try {
    var called = 0;
    var iteratorWithReturn = {
        next: function() {
            return {
                done: !!called++
            };
        },
        'return': function() {
            SAFE_CLOSING = true;
        }
    };
    iteratorWithReturn[ITERATOR] = function() {
        return this;
    };
    // eslint-disable-next-line no-throw-literal
    Array.from(iteratorWithReturn, function() {
        throw 2;
    });
} catch (error) { /* empty */ }

var checkCorrectnessOfIteration$1 = function(exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;
    try {
        var object = {};
        object[ITERATOR] = function() {
            return {
                next: function() {
                    return {
                        done: ITERATION_SUPPORT = true
                    };
                }
            };
        };
        exec(object);
    } catch (error) { /* empty */ }
    return ITERATION_SUPPORT;
};

var anObject$1 = anObject$6;
var aFunction$2 = aFunction$4;
var wellKnownSymbol$1 = wellKnownSymbol$9;

var SPECIES$1 = wellKnownSymbol$1('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
var speciesConstructor$1 = function(O, defaultConstructor) {
    var C = anObject$1(O).constructor;
    var S;
    return C === undefined || (S = anObject$1(C)[SPECIES$1]) == undefined ? defaultConstructor : aFunction$2(S);
};

var getBuiltIn$2 = getBuiltIn$5;

var html$1 = getBuiltIn$2('document', 'documentElement');

var getBuiltIn$1 = getBuiltIn$5;

var engineUserAgent = getBuiltIn$1('navigator', 'userAgent') || '';

var userAgent$1 = engineUserAgent;

var engineIsIos = /(iphone|ipod|ipad).*applewebkit/i.test(userAgent$1);

var global$5 = global$h;
var fails = fails$6;
var classof$2 = classofRaw$1;
var bind$1 = functionBindContext;
var html = html$1;
var createElement = documentCreateElement;
var IS_IOS$1 = engineIsIos;

var location = global$5.location;
var set = global$5.setImmediate;
var clear = global$5.clearImmediate;
var process$3 = global$5.process;
var MessageChannel = global$5.MessageChannel;
var Dispatch = global$5.Dispatch;
var counter = 0;
var queue = {};
var ONREADYSTATECHANGE = 'onreadystatechange';
var defer, channel, port;

var run = function(id) {
    // eslint-disable-next-line no-prototype-builtins
    if (queue.hasOwnProperty(id)) {
        var fn = queue[id];
        delete queue[id];
        fn();
    }
};

var runner = function(id) {
    return function() {
        run(id);
    };
};

var listener = function(event) {
    run(event.data);
};

var post = function(id) {
    // old engines have not location.origin
    global$5.postMessage(id + '', location.protocol + '//' + location.host);
};

// Node.js 0.9+ & IE10+ has setImmediate, otherwise:
if (!set || !clear) {
    set = function setImmediate(fn) {
        var args = [];
        var i = 1;
        while (arguments.length > i) args.push(arguments[i++]);
        queue[++counter] = function() {
            // eslint-disable-next-line no-new-func
            (typeof fn == 'function' ? fn : Function(fn)).apply(undefined, args);
        };
        defer(counter);
        return counter;
    };
    clear = function clearImmediate(id) {
        delete queue[id];
    };
    // Node.js 0.8-
    if (classof$2(process$3) == 'process') {
        defer = function(id) {
            process$3.nextTick(runner(id));
        };
        // Sphere (JS game engine) Dispatch API
    } else if (Dispatch && Dispatch.now) {
        defer = function(id) {
            Dispatch.now(runner(id));
        };
        // Browsers with MessageChannel, includes WebWorkers
        // except iOS - https://github.com/zloirock/core-js/issues/624
    } else if (MessageChannel && !IS_IOS$1) {
        channel = new MessageChannel();
        port = channel.port2;
        channel.port1.onmessage = listener;
        defer = bind$1(port.postMessage, port, 1);
        // Browsers with postMessage, skip WebWorkers
        // IE8 has postMessage, but it's sync & typeof its postMessage is 'object'
    } else if (
        global$5.addEventListener &&
        typeof postMessage == 'function' &&
        !global$5.importScripts &&
        !fails(post) &&
        location.protocol !== 'file:'
    ) {
        defer = post;
        global$5.addEventListener('message', listener, false);
        // IE8-
    } else if (ONREADYSTATECHANGE in createElement('script')) {
        defer = function(id) {
            html.appendChild(createElement('script'))[ONREADYSTATECHANGE] = function() {
                html.removeChild(this);
                run(id);
            };
        };
        // Rest old browsers
    } else {
        defer = function(id) {
            setTimeout(runner(id), 0);
        };
    }
}

var task$1 = {
    set: set,
    clear: clear
};

var global$4 = global$h;
var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var classof$1 = classofRaw$1;
var macrotask = task$1.set;
var IS_IOS = engineIsIos;

var MutationObserver = global$4.MutationObserver || global$4.WebKitMutationObserver;
var process$2 = global$4.process;
var Promise$1 = global$4.Promise;
var IS_NODE$1 = classof$1(process$2) == 'process';
// Node.js 11 shows ExperimentalWarning on getting `queueMicrotask`
var queueMicrotaskDescriptor = getOwnPropertyDescriptor(global$4, 'queueMicrotask');
var queueMicrotask = queueMicrotaskDescriptor && queueMicrotaskDescriptor.value;

var flush, head, last, notify$1, toggle, node, promise, then;

// modern engines have queueMicrotask method
if (!queueMicrotask) {
    flush = function() {
        var parent, fn;
        if (IS_NODE$1 && (parent = process$2.domain)) parent.exit();
        while (head) {
            fn = head.fn;
            head = head.next;
            try {
                fn();
            } catch (error) {
                if (head) notify$1();
                else last = undefined;
                throw error;
            }
        }
        last = undefined;
        if (parent) parent.enter();
    };

    // Node.js
    if (IS_NODE$1) {
        notify$1 = function() {
            process$2.nextTick(flush);
        };
        // browsers with MutationObserver, except iOS - https://github.com/zloirock/core-js/issues/339
    } else if (MutationObserver && !IS_IOS) {
        toggle = true;
        node = document.createTextNode('');
        new MutationObserver(flush).observe(node, {
            characterData: true
        });
        notify$1 = function() {
            node.data = toggle = !toggle;
        };
        // environments with maybe non-completely correct, but existent Promise
    } else if (Promise$1 && Promise$1.resolve) {
        // Promise.resolve without an argument throws an error in LG WebOS 2
        promise = Promise$1.resolve(undefined);
        then = promise.then;
        notify$1 = function() {
            then.call(promise, flush);
        };
        // for other environments - macrotask based on:
        // - setImmediate
        // - MessageChannel
        // - window.postMessag
        // - onreadystatechange
        // - setTimeout
    } else {
        notify$1 = function() {
            // strange IE + webpack dev server bug - use .call(global)
            macrotask.call(global$4, flush);
        };
    }
}

var microtask$1 = queueMicrotask || function(fn) {
    var task = {
        fn: fn,
        next: undefined
    };
    if (last) last.next = task;
    if (!head) {
        head = task;
        notify$1();
    }
    last = task;
};

var newPromiseCapability$2 = {};

var aFunction$1 = aFunction$4;

var PromiseCapability = function(C) {
    var resolve, reject;
    this.promise = new C(function($$resolve, $$reject) {
        if (resolve !== undefined || reject !== undefined) throw TypeError('Bad Promise constructor');
        resolve = $$resolve;
        reject = $$reject;
    });
    this.resolve = aFunction$1(resolve);
    this.reject = aFunction$1(reject);
};

// 25.4.1.5 NewPromiseCapability(C)
newPromiseCapability$2.f = function(C) {
    return new PromiseCapability(C);
};

var anObject = anObject$6;
var isObject$1 = isObject$6;
var newPromiseCapability$1 = newPromiseCapability$2;

var promiseResolve$1 = function(C, x) {
    anObject(C);
    if (isObject$1(x) && x.constructor === C) return x;
    var promiseCapability = newPromiseCapability$1.f(C);
    var resolve = promiseCapability.resolve;
    resolve(x);
    return promiseCapability.promise;
};

var global$3 = global$h;

var hostReportErrors$1 = function(a, b) {
    var console = global$3.console;
    if (console && console.error) {
        arguments.length === 1 ? console.error(a) : console.error(a, b);
    }
};

var perform$1 = function(exec) {
    try {
        return {
            error: false,
            value: exec()
        };
    } catch (error) {
        return {
            error: true,
            value: error
        };
    }
};

var global$2 = global$h;
var userAgent = engineUserAgent;

var process$1 = global$2.process;
var versions = process$1 && process$1.versions;
var v8 = versions && versions.v8;
var match, version;

if (v8) {
    match = v8.split('.');
    version = match[0] + match[1];
} else if (userAgent) {
    match = userAgent.match(/Edge\/(\d+)/);
    if (!match || match[1] >= 74) {
        match = userAgent.match(/Chrome\/(\d+)/);
        if (match) version = match[1];
    }
}

var engineV8Version = version && +version;

var $ = _export;
var global$1 = global$h;
var getBuiltIn = getBuiltIn$5;
var NativePromise = nativePromiseConstructor;
var redefine = redefine$3.exports;
var redefineAll = redefineAll$1;
var setToStringTag = setToStringTag$1;
var setSpecies = setSpecies$1;
var isObject = isObject$6;
var aFunction = aFunction$4;
var anInstance = anInstance$1;
var classof = classofRaw$1;
var inspectSource = inspectSource$3;
var iterate = iterate$2.exports;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
var speciesConstructor = speciesConstructor$1;
var task = task$1.set;
var microtask = microtask$1;
var promiseResolve = promiseResolve$1;
var hostReportErrors = hostReportErrors$1;
var newPromiseCapabilityModule = newPromiseCapability$2;
var perform = perform$1;
var InternalStateModule = internalState;
var isForced = isForced_1;
var wellKnownSymbol = wellKnownSymbol$9;
var V8_VERSION = engineV8Version;

var SPECIES = wellKnownSymbol('species');
var PROMISE = 'Promise';
var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var getInternalPromiseState = InternalStateModule.getterFor(PROMISE);
var PromiseConstructor = NativePromise;
var TypeError$1 = global$1.TypeError;
var document$1 = global$1.document;
var process = global$1.process;
var $fetch = getBuiltIn('fetch');
var newPromiseCapability = newPromiseCapabilityModule.f;
var newGenericPromiseCapability = newPromiseCapability;
var IS_NODE = classof(process) == 'process';
var DISPATCH_EVENT = !!(document$1 && document$1.createEvent && global$1.dispatchEvent);
var UNHANDLED_REJECTION = 'unhandledrejection';
var REJECTION_HANDLED = 'rejectionhandled';
var PENDING = 0;
var FULFILLED = 1;
var REJECTED = 2;
var HANDLED = 1;
var UNHANDLED = 2;
var Internal, OwnPromiseCapability, PromiseWrapper, nativeThen;

var FORCED = isForced(PROMISE, function() {
    var GLOBAL_CORE_JS_PROMISE = inspectSource(PromiseConstructor) !== String(PromiseConstructor);
    if (!GLOBAL_CORE_JS_PROMISE) {
        // V8 6.6 (Node 10 and Chrome 66) have a bug with resolving custom thenables
        // https://bugs.chromium.org/p/chromium/issues/detail?id=830565
        // We can't detect it synchronously, so just check versions
        if (V8_VERSION === 66) return true;
        // Unhandled rejections tracking support, NodeJS Promise without it fails @@species test
        if (!IS_NODE && typeof PromiseRejectionEvent != 'function') return true;
    }
    // We can't use @@species feature detection in V8 since it causes
    // deoptimization and performance degradation
    // https://github.com/zloirock/core-js/issues/679
    if (V8_VERSION >= 51 && /native code/.test(PromiseConstructor)) return false;
    // Detect correctness of subclassing with @@species support
    var promise = PromiseConstructor.resolve(1);
    var FakePromise = function(exec) {
        exec(function() { /* empty */ }, function() { /* empty */ });
    };
    var constructor = promise.constructor = {};
    constructor[SPECIES] = FakePromise;
    return !(promise.then(function() { /* empty */ }) instanceof FakePromise);
});

var INCORRECT_ITERATION = FORCED || !checkCorrectnessOfIteration(function(iterable) {
    PromiseConstructor.all(iterable)['catch'](function() { /* empty */ });
});

// helpers
var isThenable = function(it) {
    var then;
    return isObject(it) && typeof(then = it.then) == 'function' ? then : false;
};

var notify = function(promise, state, isReject) {
    if (state.notified) return;
    state.notified = true;
    var chain = state.reactions;
    microtask(function() {
        var value = state.value;
        var ok = state.state == FULFILLED;
        var index = 0;
        // variable length - can't use forEach
        while (chain.length > index) {
            var reaction = chain[index++];
            var handler = ok ? reaction.ok : reaction.fail;
            var resolve = reaction.resolve;
            var reject = reaction.reject;
            var domain = reaction.domain;
            var result, then, exited;
            try {
                if (handler) {
                    if (!ok) {
                        if (state.rejection === UNHANDLED) onHandleUnhandled(promise, state);
                        state.rejection = HANDLED;
                    }
                    if (handler === true) result = value;
                    else {
                        if (domain) domain.enter();
                        result = handler(value); // can throw
                        if (domain) {
                            domain.exit();
                            exited = true;
                        }
                    }
                    if (result === reaction.promise) {
                        reject(TypeError$1('Promise-chain cycle'));
                    } else if (then = isThenable(result)) {
                        then.call(result, resolve, reject);
                    } else resolve(result);
                } else reject(value);
            } catch (error) {
                if (domain && !exited) domain.exit();
                reject(error);
            }
        }
        state.reactions = [];
        state.notified = false;
        if (isReject && !state.rejection) onUnhandled(promise, state);
    });
};

var dispatchEvent = function(name, promise, reason) {
    var event, handler;
    if (DISPATCH_EVENT) {
        event = document$1.createEvent('Event');
        event.promise = promise;
        event.reason = reason;
        event.initEvent(name, false, true);
        global$1.dispatchEvent(event);
    } else event = {
        promise: promise,
        reason: reason
    };
    if (handler = global$1['on' + name]) handler(event);
    else if (name === UNHANDLED_REJECTION) hostReportErrors('Unhandled promise rejection', reason);
};

var onUnhandled = function(promise, state) {
    task.call(global$1, function() {
        var value = state.value;
        var IS_UNHANDLED = isUnhandled(state);
        var result;
        if (IS_UNHANDLED) {
            result = perform(function() {
                if (IS_NODE) {
                    process.emit('unhandledRejection', value, promise);
                } else dispatchEvent(UNHANDLED_REJECTION, promise, value);
            });
            // Browsers should not trigger `rejectionHandled` event if it was handled here, NodeJS - should
            state.rejection = IS_NODE || isUnhandled(state) ? UNHANDLED : HANDLED;
            if (result.error) throw result.value;
        }
    });
};

var isUnhandled = function(state) {
    return state.rejection !== HANDLED && !state.parent;
};

var onHandleUnhandled = function(promise, state) {
    task.call(global$1, function() {
        if (IS_NODE) {
            process.emit('rejectionHandled', promise);
        } else dispatchEvent(REJECTION_HANDLED, promise, state.value);
    });
};

var bind = function(fn, promise, state, unwrap) {
    return function(value) {
        fn(promise, state, value, unwrap);
    };
};

var internalReject = function(promise, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    state.value = value;
    state.state = REJECTED;
    notify(promise, state, true);
};

var internalResolve = function(promise, state, value, unwrap) {
    if (state.done) return;
    state.done = true;
    if (unwrap) state = unwrap;
    try {
        if (promise === value) throw TypeError$1("Promise can't be resolved itself");
        var then = isThenable(value);
        if (then) {
            microtask(function() {
                var wrapper = {
                    done: false
                };
                try {
                    then.call(value,
                        bind(internalResolve, promise, wrapper, state),
                        bind(internalReject, promise, wrapper, state)
                    );
                } catch (error) {
                    internalReject(promise, wrapper, error, state);
                }
            });
        } else {
            state.value = value;
            state.state = FULFILLED;
            notify(promise, state, false);
        }
    } catch (error) {
        internalReject(promise, {
            done: false
        }, error, state);
    }
};

// constructor polyfill
if (FORCED) {
    // 25.4.3.1 Promise(executor)
    PromiseConstructor = function Promise(executor) {
        anInstance(this, PromiseConstructor, PROMISE);
        aFunction(executor);
        Internal.call(this);
        var state = getInternalState(this);
        try {
            executor(bind(internalResolve, this, state), bind(internalReject, this, state));
        } catch (error) {
            internalReject(this, state, error);
        }
    };
    // eslint-disable-next-line no-unused-vars
    Internal = function Promise(executor) {
        setInternalState(this, {
            type: PROMISE,
            done: false,
            notified: false,
            parent: false,
            reactions: [],
            rejection: false,
            state: PENDING,
            value: undefined
        });
    };
    Internal.prototype = redefineAll(PromiseConstructor.prototype, {
        // `Promise.prototype.then` method
        // https://tc39.github.io/ecma262/#sec-promise.prototype.then
        then: function then(onFulfilled, onRejected) {
            var state = getInternalPromiseState(this);
            var reaction = newPromiseCapability(speciesConstructor(this, PromiseConstructor));
            reaction.ok = typeof onFulfilled == 'function' ? onFulfilled : true;
            reaction.fail = typeof onRejected == 'function' && onRejected;
            reaction.domain = IS_NODE ? process.domain : undefined;
            state.parent = true;
            state.reactions.push(reaction);
            if (state.state != PENDING) notify(this, state, false);
            return reaction.promise;
        },
        // `Promise.prototype.catch` method
        // https://tc39.github.io/ecma262/#sec-promise.prototype.catch
        'catch': function(onRejected) {
            return this.then(undefined, onRejected);
        }
    });
    OwnPromiseCapability = function() {
        var promise = new Internal();
        var state = getInternalState(promise);
        this.promise = promise;
        this.resolve = bind(internalResolve, promise, state);
        this.reject = bind(internalReject, promise, state);
    };
    newPromiseCapabilityModule.f = newPromiseCapability = function(C) {
        return C === PromiseConstructor || C === PromiseWrapper ?
            new OwnPromiseCapability(C) :
            newGenericPromiseCapability(C);
    };

    if (typeof NativePromise == 'function') {
        nativeThen = NativePromise.prototype.then;

        // wrap native Promise#then for native async functions
        redefine(NativePromise.prototype, 'then', function then(onFulfilled, onRejected) {
            var that = this;
            return new PromiseConstructor(function(resolve, reject) {
                nativeThen.call(that, resolve, reject);
            }).then(onFulfilled, onRejected);
            // https://github.com/zloirock/core-js/issues/640
        }, {
            unsafe: true
        });

        // wrap fetch result
        if (typeof $fetch == 'function') $({
            global: true,
            enumerable: true,
            forced: true
        }, {
            // eslint-disable-next-line no-unused-vars
            fetch: function fetch(input /* , init */ ) {
                return promiseResolve(PromiseConstructor, $fetch.apply(global$1, arguments));
            }
        });
    }
}

$({
    global: true,
    wrap: true,
    forced: FORCED
}, {
    Promise: PromiseConstructor
});

setToStringTag(PromiseConstructor, PROMISE, false);
setSpecies(PROMISE);

PromiseWrapper = getBuiltIn(PROMISE);

// statics
$({
    target: PROMISE,
    stat: true,
    forced: FORCED
}, {
    // `Promise.reject` method
    // https://tc39.github.io/ecma262/#sec-promise.reject
    reject: function reject(r) {
        var capability = newPromiseCapability(this);
        capability.reject.call(undefined, r);
        return capability.promise;
    }
});

$({
    target: PROMISE,
    stat: true,
    forced: FORCED
}, {
    // `Promise.resolve` method
    // https://tc39.github.io/ecma262/#sec-promise.resolve
    resolve: function resolve(x) {
        return promiseResolve(this, x);
    }
});

$({
    target: PROMISE,
    stat: true,
    forced: INCORRECT_ITERATION
}, {
    // `Promise.all` method
    // https://tc39.github.io/ecma262/#sec-promise.all
    all: function all(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        var result = perform(function() {
            var $promiseResolve = aFunction(C.resolve);
            var values = [];
            var counter = 0;
            var remaining = 1;
            iterate(iterable, function(promise) {
                var index = counter++;
                var alreadyCalled = false;
                values.push(undefined);
                remaining++;
                $promiseResolve.call(C, promise).then(function(value) {
                    if (alreadyCalled) return;
                    alreadyCalled = true;
                    values[index] = value;
                    --remaining || resolve(values);
                }, reject);
            });
            --remaining || resolve(values);
        });
        if (result.error) reject(result.value);
        return capability.promise;
    },
    // `Promise.race` method
    // https://tc39.github.io/ecma262/#sec-promise.race
    race: function race(iterable) {
        var C = this;
        var capability = newPromiseCapability(C);
        var reject = capability.reject;
        var result = perform(function() {
            var $promiseResolve = aFunction(C.resolve);
            iterate(iterable, function(promise) {
                $promiseResolve.call(C, promise).then(capability.resolve, reject);
            });
        });
        if (result.error) reject(result.value);
        return capability.promise;
    }
});

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new(P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }

        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }

        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var icon = `data:image/png;base64,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`;

const NARWALLETS_CODES = {
    SIGN_IN: "sign-in",
    IS_INSTALLED: "is-installed",
    IS_SIGNED_IN: "is-signed-in",
    SIGN_OUT: "sign-out",
    GET_ACCOUNT_ID: "get-account-id",
    SIGN_AND_SEND_TRANSACTION: "sign-and-send-transaction",
    SIGN_AND_SEND_TRANSACTIONS: "sign-and-send-transactions"
};
let id = 0;
const pendingPromises = [];
const sendToNarwallets = (code, withTimeout = false, params) => {
    const promise = new Promise((resolve, reject) => {
        id++;
        let promiseTimeout;
        if (withTimeout) {
            promiseTimeout = setTimeout(() => {
                return reject(Error("timeout"));
            }, 2000);
        }
        pendingPromises.push({
            id_wallet_selector: id,
            code,
            resolve,
            reject,
            timeout: promiseTimeout
        });
        window.postMessage({
            id,
            src: "ws",
            type: "nw",
            code,
            dest: "ext",
            params
        });
    });
    return promise;
};
const isInstalled = () => __awaiter(void 0, void 0, void 0, function*() {
    // Note: sendToNarwallets throws if not installed
    return waitFor(() => !!window.narwallets).catch(() => false);
});
const isSignedIn = () => {
    return sendToNarwallets(NARWALLETS_CODES.IS_SIGNED_IN, true);
};
const getAccountId = () => {
    return sendToNarwallets(NARWALLETS_CODES.GET_ACCOUNT_ID, false);
};
const callSignAndSendTransaction = params => {
    return sendToNarwallets(NARWALLETS_CODES.SIGN_AND_SEND_TRANSACTION, false, params);
};
const callSignAndSendTransactions = params => {
    return sendToNarwallets(NARWALLETS_CODES.SIGN_AND_SEND_TRANSACTIONS, false, params);
};
const findPendingPromiseById = promiseId => {
    return pendingPromises.filter(c => c.id_wallet_selector === promiseId)[0];
};
const removePendingPromise = callback => {
    const index = pendingPromises.indexOf(callback);
    if (index > -1) {
        // only splice array when item is found
        pendingPromises.splice(index, 1); // 2nd parameter means remove one item only
    }
};
const setupNarwalletsState = () => {
    // receive response from the extension content_script
    window.addEventListener("message", event => {
        if (event.source !== window) {
            return;
        }
        const {
            data
        } = event;
        // msg should be directed to the page (response from the extension, relayed from the content script)
        if (!data || data.dest !== "page") {
            return;
        }
        if (data.id && data.type === "nw") {
            const pendingPromise = findPendingPromiseById(data.id);
            if (pendingPromise) {
                removePendingPromise(pendingPromise);
                if (pendingPromise.timeout) {
                    clearTimeout(pendingPromise.timeout);
                }
                if (!data.result) {
                    pendingPromise.reject("result is empty");
                } else if (data.result.err) {
                    pendingPromise.reject(data.result.err);
                } else {
                    pendingPromise.resolve(data.result.data);
                }
            }
        }
    });
};
const Narwallets = ({
    metadata,
    store,
    logger
}) => __awaiter(void 0, void 0, void 0, function*() {
    const signOut = () => __awaiter(void 0, void 0, void 0, function*() {
        if (!(yield isSignedIn())) {
            return;
        }
        const res = yield sendToNarwallets("sign-out");
        // const res = await _state.wallet.signOut();
        if (res === true) {
            return;
        }
        const errorObject = res;
        const error = new Error(typeof errorObject.error === "string" ? errorObject.error : errorObject.error.type);
        // Prevent signing out by throwing.
        if (error.message === "User reject") {
            throw error;
        }
        // Continue signing out but log the issue.
        logger.log("Failed to sign out");
        logger.error(error);
    });
    return {
        signIn() {
            return __awaiter(this, void 0, void 0, function*() {
                const isUserSignedIn = yield isSignedIn();
                let code;
                if (!isUserSignedIn) {
                    code = NARWALLETS_CODES.SIGN_IN;
                } else {
                    code = NARWALLETS_CODES.GET_ACCOUNT_ID;
                }
                const response = yield sendToNarwallets(code);
                return [{
                    accountId: response
                }];
            });
        },
        signOut,
        getAccounts() {
            return __awaiter(this, void 0, void 0, function*() {
                const accountId = yield getAccountId();
                return [{
                    accountId
                }];
            });
        },
        verifyOwner({
            message
        }) {
            return __awaiter(this, void 0, void 0, function*() {
                logger.log("Narwallets:verifyOwner", {
                    message
                });
                throw new Error(`Method not supported by ${metadata.name}`);
            });
        },
        signAndSendTransaction({
            signerId,
            receiverId,
            actions
        }) {
            return __awaiter(this, void 0, void 0, function*() {
                logger.log("signAndSendTransaction", {
                    signerId,
                    receiverId,
                    actions
                });
                const {
                    contract,
                    accounts
                } = store.getState();
                if (!accounts || accounts.length === 0 || !contract) {
                    throw new Error("Wallet not signed in");
                }
                return callSignAndSendTransaction({
                    signerId,
                    receiverId: receiverId || contract.contractId,
                    actions: actions
                });
            });
        },
        signAndSendTransactions({
            transactions
        }) {
            return __awaiter(this, void 0, void 0, function*() {
                logger.log("signAndSendTransactions", {
                    transactions
                });
                const {
                    contract,
                    accounts
                } = store.getState();
                // test: avoid a call to isSignedIn
                if (!accounts || accounts.length === 0 || !contract) {
                    throw new Error("Wallet not signed in");
                }
                return callSignAndSendTransactions(transactions);
            });
        }
    };
});
const setupNarwallets = ({
    iconUrl: _iconUrl = icon,
    deprecated: _deprecated = false
} = {}) => {
    return () => __awaiter(void 0, void 0, void 0, function*() {
        const mobile = isMobile();
        if (mobile) {
            return null;
        }
        setupNarwalletsState();
        const installed = yield isInstalled();
        return {
            id: "narwallets",
            type: "injected",
            metadata: {
                name: "Narwallets",
                description: null,
                iconUrl: _iconUrl,
                downloadUrl: "https://chrome.google.com/webstore/detail/narwallets-v4/lkpeokpdkmcdaiadpmnnpimlgmdobkdj",
                deprecated: _deprecated,
                available: installed
            },
            init: Narwallets
        };
    });
};

export {
    setupNarwallets
};