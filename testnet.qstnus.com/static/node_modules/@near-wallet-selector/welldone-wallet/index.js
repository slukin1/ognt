import * as nearAPI from 'near-api-js';
import {
    isCurrentBrowserSupported,
    waitFor,
    serializeNep413
} from '@near-wallet-selector/core';
import {
    signTransactions
} from '@near-wallet-selector/wallet-utils';
import isMobile from 'is-mobile';

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

var fails$d = function(exec) {
    try {
        return !!exec();
    } catch (error) {
        return true;
    }
};

var toString = {}.toString;

var classofRaw$1 = function(it) {
    return toString.call(it).slice(8, -1);
};

var fails$c = fails$d;
var classof$5 = classofRaw$1;

var split = ''.split;

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var indexedObject = fails$c(function() {
    // throws an error in rhino, see https://github.com/mozilla/rhino/issues/346
    // eslint-disable-next-line no-prototype-builtins
    return !Object('z').propertyIsEnumerable(0);
}) ? function(it) {
    return classof$5(it) == 'String' ? split.call(it, '') : Object(it);
} : Object;

// `RequireObjectCoercible` abstract operation
// https://tc39.github.io/ecma262/#sec-requireobjectcoercible
var requireObjectCoercible$2 = function(it) {
    if (it == undefined) throw TypeError("Can't call method on " + it);
    return it;
};

// toObject with fallback for non-array-like ES3 strings
var IndexedObject$2 = indexedObject;
var requireObjectCoercible$1 = requireObjectCoercible$2;

var toIndexedObject$4 = function(it) {
    return IndexedObject$2(requireObjectCoercible$1(it));
};

var check = function(it) {
    return it && it.Math == Math && it;
};

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global$h =
    // eslint-disable-next-line no-undef
    check(typeof globalThis == 'object' && globalThis) ||
    check(typeof window == 'object' && window) ||
    check(typeof self == 'object' && self) ||
    check(typeof commonjsGlobal == 'object' && commonjsGlobal) ||
    // eslint-disable-next-line no-new-func
    Function('return this')();

var shared$2 = {
    exports: {}
};

var fails$b = fails$d;

// Thank's IE8 for his funny defineProperty
var descriptors = !fails$b(function() {
    return Object.defineProperty({}, 1, {
        get: function() {
            return 7;
        }
    })[1] != 7;
});

var objectDefineProperty = {};

var isObject$9 = function(it) {
    return typeof it === 'object' ? it !== null : typeof it === 'function';
};

var global$g = global$h;
var isObject$8 = isObject$9;

var document$1 = global$g.document;
// typeof document.createElement is 'object' in old IE
var EXISTS = isObject$8(document$1) && isObject$8(document$1.createElement);

var documentCreateElement$1 = function(it) {
    return EXISTS ? document$1.createElement(it) : {};
};

var DESCRIPTORS$9 = descriptors;
var fails$a = fails$d;
var createElement = documentCreateElement$1;

// Thank's IE8 for his funny defineProperty
var ie8DomDefine = !DESCRIPTORS$9 && !fails$a(function() {
    return Object.defineProperty(createElement('div'), 'a', {
        get: function() {
            return 7;
        }
    }).a != 7;
});

var isObject$7 = isObject$9;

var anObject$9 = function(it) {
    if (!isObject$7(it)) {
        throw TypeError(String(it) + ' is not an object');
    }
    return it;
};

var isObject$6 = isObject$9;

// `ToPrimitive` abstract operation
// https://tc39.github.io/ecma262/#sec-toprimitive
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
var toPrimitive$3 = function(input, PREFERRED_STRING) {
    if (!isObject$6(input)) return input;
    var fn, val;
    if (PREFERRED_STRING && typeof(fn = input.toString) == 'function' && !isObject$6(val = fn.call(input))) return val;
    if (typeof(fn = input.valueOf) == 'function' && !isObject$6(val = fn.call(input))) return val;
    if (!PREFERRED_STRING && typeof(fn = input.toString) == 'function' && !isObject$6(val = fn.call(input))) return val;
    throw TypeError("Can't convert object to primitive value");
};

var DESCRIPTORS$8 = descriptors;
var IE8_DOM_DEFINE$1 = ie8DomDefine;
var anObject$8 = anObject$9;
var toPrimitive$2 = toPrimitive$3;

var nativeDefineProperty$1 = Object.defineProperty;

// `Object.defineProperty` method
// https://tc39.github.io/ecma262/#sec-object.defineproperty
objectDefineProperty.f = DESCRIPTORS$8 ? nativeDefineProperty$1 : function defineProperty(O, P, Attributes) {
    anObject$8(O);
    P = toPrimitive$2(P, true);
    anObject$8(Attributes);
    if (IE8_DOM_DEFINE$1) try {
        return nativeDefineProperty$1(O, P, Attributes);
    } catch (error) { /* empty */ }
    if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported');
    if ('value' in Attributes) O[P] = Attributes.value;
    return O;
};

var createPropertyDescriptor$4 = function(bitmap, value) {
    return {
        enumerable: !(bitmap & 1),
        configurable: !(bitmap & 2),
        writable: !(bitmap & 4),
        value: value
    };
};

var DESCRIPTORS$7 = descriptors;
var definePropertyModule$5 = objectDefineProperty;
var createPropertyDescriptor$3 = createPropertyDescriptor$4;

var createNonEnumerableProperty$a = DESCRIPTORS$7 ? function(object, key, value) {
    return definePropertyModule$5.f(object, key, createPropertyDescriptor$3(1, value));
} : function(object, key, value) {
    object[key] = value;
    return object;
};

var global$f = global$h;
var createNonEnumerableProperty$9 = createNonEnumerableProperty$a;

var setGlobal$3 = function(key, value) {
    try {
        createNonEnumerableProperty$9(global$f, key, value);
    } catch (error) {
        global$f[key] = value;
    }
    return value;
};

var global$e = global$h;
var setGlobal$2 = setGlobal$3;

var SHARED = '__core-js_shared__';
var store$3 = global$e[SHARED] || setGlobal$2(SHARED, {});

var sharedStore = store$3;

var store$2 = sharedStore;

(shared$2.exports = function(key, value) {
    return store$2[key] || (store$2[key] = value !== undefined ? value : {});
})('versions', []).push({
    version: '3.6.5',
    mode: 'global',
    copyright: 'Â© 2020 Denis Pushkarev (zloirock.ru)'
});

var hasOwnProperty = {}.hasOwnProperty;

var has$b = function(it, key) {
    return hasOwnProperty.call(it, key);
};

var id = 0;
var postfix = Math.random();

var uid$3 = function(key) {
    return 'Symbol(' + String(key === undefined ? '' : key) + ')_' + (++id + postfix).toString(36);
};

var fails$9 = fails$d;

var nativeSymbol = !!Object.getOwnPropertySymbols && !fails$9(function() {
    // Chrome 38 Symbol has incorrect toString conversion
    // eslint-disable-next-line no-undef
    return !String(Symbol());
});

var NATIVE_SYMBOL$1 = nativeSymbol;

var useSymbolAsUid = NATIVE_SYMBOL$1
    // eslint-disable-next-line no-undef
    &&
    !Symbol.sham
    // eslint-disable-next-line no-undef
    &&
    typeof Symbol.iterator == 'symbol';

var global$d = global$h;
var shared$1 = shared$2.exports;
var has$a = has$b;
var uid$2 = uid$3;
var NATIVE_SYMBOL = nativeSymbol;
var USE_SYMBOL_AS_UID = useSymbolAsUid;

var WellKnownSymbolsStore = shared$1('wks');
var Symbol$1 = global$d.Symbol;
var createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol$1 : Symbol$1 && Symbol$1.withoutSetter || uid$2;

var wellKnownSymbol$e = function(name) {
    if (!has$a(WellKnownSymbolsStore, name)) {
        if (NATIVE_SYMBOL && has$a(Symbol$1, name)) WellKnownSymbolsStore[name] = Symbol$1[name];
        else WellKnownSymbolsStore[name] = createWellKnownSymbol('Symbol.' + name);
    }
    return WellKnownSymbolsStore[name];
};

var ceil = Math.ceil;
var floor$1 = Math.floor;

// `ToInteger` abstract operation
// https://tc39.github.io/ecma262/#sec-tointeger
var toInteger$5 = function(argument) {
    return isNaN(argument = +argument) ? 0 : (argument > 0 ? floor$1 : ceil)(argument);
};

var toInteger$4 = toInteger$5;

var min$1 = Math.min;

// `ToLength` abstract operation
// https://tc39.github.io/ecma262/#sec-tolength
var toLength$9 = function(argument) {
    return argument > 0 ? min$1(toInteger$4(argument), 0x1FFFFFFFFFFFFF) : 0; // 2 ** 53 - 1 == 9007199254740991
};

var toInteger$3 = toInteger$5;

var max = Math.max;
var min = Math.min;

// Helper for a popular repeating case of the spec:
// Let integer be ? ToInteger(index).
// If integer < 0, let result be max((length + integer), 0); else let result be min(integer, length).
var toAbsoluteIndex$3 = function(index, length) {
    var integer = toInteger$3(index);
    return integer < 0 ? max(integer + length, 0) : min(integer, length);
};

var toIndexedObject$3 = toIndexedObject$4;
var toLength$8 = toLength$9;
var toAbsoluteIndex$2 = toAbsoluteIndex$3;

// `Array.prototype.{ indexOf, includes }` methods implementation
var createMethod$1 = function(IS_INCLUDES) {
    return function($this, el, fromIndex) {
        var O = toIndexedObject$3($this);
        var length = toLength$8(O.length);
        var index = toAbsoluteIndex$2(fromIndex, length);
        var value;
        // Array#includes uses SameValueZero equality algorithm
        // eslint-disable-next-line no-self-compare
        if (IS_INCLUDES && el != el)
            while (length > index) {
                value = O[index++];
                // eslint-disable-next-line no-self-compare
                if (value != value) return true;
                // Array#indexOf ignores holes, Array#includes - not
            } else
                for (; length > index; index++) {
                    if ((IS_INCLUDES || index in O) && O[index] === el) return IS_INCLUDES || index || 0;
                }
        return !IS_INCLUDES && -1;
    };
};

var arrayIncludes = {
    // `Array.prototype.includes` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.includes
    includes: createMethod$1(true),
    // `Array.prototype.indexOf` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.indexof
    indexOf: createMethod$1(false)
};

var hiddenKeys$4 = {};

var has$9 = has$b;
var toIndexedObject$2 = toIndexedObject$4;
var indexOf = arrayIncludes.indexOf;
var hiddenKeys$3 = hiddenKeys$4;

var objectKeysInternal = function(object, names) {
    var O = toIndexedObject$2(object);
    var i = 0;
    var result = [];
    var key;
    for (key in O) !has$9(hiddenKeys$3, key) && has$9(O, key) && result.push(key);
    // Don't enum bug & hidden keys
    while (names.length > i)
        if (has$9(O, key = names[i++])) {
            ~indexOf(result, key) || result.push(key);
        }
    return result;
};

// IE8- don't enum bug keys
var enumBugKeys$3 = [
    'constructor',
    'hasOwnProperty',
    'isPrototypeOf',
    'propertyIsEnumerable',
    'toLocaleString',
    'toString',
    'valueOf'
];

var internalObjectKeys$1 = objectKeysInternal;
var enumBugKeys$2 = enumBugKeys$3;

// `Object.keys` method
// https://tc39.github.io/ecma262/#sec-object.keys
var objectKeys$2 = Object.keys || function keys(O) {
    return internalObjectKeys$1(O, enumBugKeys$2);
};

var DESCRIPTORS$6 = descriptors;
var definePropertyModule$4 = objectDefineProperty;
var anObject$7 = anObject$9;
var objectKeys$1 = objectKeys$2;

// `Object.defineProperties` method
// https://tc39.github.io/ecma262/#sec-object.defineproperties
var objectDefineProperties = DESCRIPTORS$6 ? Object.defineProperties : function defineProperties(O, Properties) {
    anObject$7(O);
    var keys = objectKeys$1(Properties);
    var length = keys.length;
    var index = 0;
    var key;
    while (length > index) definePropertyModule$4.f(O, key = keys[index++], Properties[key]);
    return O;
};

var global$c = global$h;

var path$1 = global$c;

var path = path$1;
var global$b = global$h;

var aFunction$3 = function(variable) {
    return typeof variable == 'function' ? variable : undefined;
};

var getBuiltIn$3 = function(namespace, method) {
    return arguments.length < 2 ? aFunction$3(path[namespace]) || aFunction$3(global$b[namespace]) :
        path[namespace] && path[namespace][method] || global$b[namespace] && global$b[namespace][method];
};

var getBuiltIn$2 = getBuiltIn$3;

var html$1 = getBuiltIn$2('document', 'documentElement');

var shared = shared$2.exports;
var uid$1 = uid$3;

var keys$1 = shared('keys');

var sharedKey$3 = function(key) {
    return keys$1[key] || (keys$1[key] = uid$1(key));
};

var anObject$6 = anObject$9;
var defineProperties = objectDefineProperties;
var enumBugKeys$1 = enumBugKeys$3;
var hiddenKeys$2 = hiddenKeys$4;
var html = html$1;
var documentCreateElement = documentCreateElement$1;
var sharedKey$2 = sharedKey$3;

var GT = '>';
var LT = '<';
var PROTOTYPE$1 = 'prototype';
var SCRIPT = 'script';
var IE_PROTO$1 = sharedKey$2('IE_PROTO');

var EmptyConstructor = function() { /* empty */ };

var scriptTag = function(content) {
    return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;
};

// Create object with fake `null` prototype: use ActiveX Object with cleared prototype
var NullProtoObjectViaActiveX = function(activeXDocument) {
    activeXDocument.write(scriptTag(''));
    activeXDocument.close();
    var temp = activeXDocument.parentWindow.Object;
    activeXDocument = null; // avoid memory leak
    return temp;
};

// Create object with fake `null` prototype: use iframe Object with cleared prototype
var NullProtoObjectViaIFrame = function() {
    // Thrash, waste and sodomy: IE GC bug
    var iframe = documentCreateElement('iframe');
    var JS = 'java' + SCRIPT + ':';
    var iframeDocument;
    iframe.style.display = 'none';
    html.appendChild(iframe);
    // https://github.com/zloirock/core-js/issues/475
    iframe.src = String(JS);
    iframeDocument = iframe.contentWindow.document;
    iframeDocument.open();
    iframeDocument.write(scriptTag('document.F=Object'));
    iframeDocument.close();
    return iframeDocument.F;
};

// Check for document.domain and active x support
// No need to use active x approach when document.domain is not set
// see https://github.com/es-shims/es5-shim/issues/150
// variation of https://github.com/kitcambridge/es5-shim/commit/4f738ac066346
// avoid IE GC bug
var activeXDocument;
var NullProtoObject = function() {
    try {
        /* global ActiveXObject */
        activeXDocument = document.domain && new ActiveXObject('htmlfile');
    } catch (error) { /* ignore */ }
    NullProtoObject = activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame();
    var length = enumBugKeys$1.length;
    while (length--) delete NullProtoObject[PROTOTYPE$1][enumBugKeys$1[length]];
    return NullProtoObject();
};

hiddenKeys$2[IE_PROTO$1] = true;

// `Object.create` method
// https://tc39.github.io/ecma262/#sec-object.create
var objectCreate = Object.create || function create(O, Properties) {
    var result;
    if (O !== null) {
        EmptyConstructor[PROTOTYPE$1] = anObject$6(O);
        result = new EmptyConstructor();
        EmptyConstructor[PROTOTYPE$1] = null;
        // add "__proto__" for Object.getPrototypeOf polyfill
        result[IE_PROTO$1] = O;
    } else result = NullProtoObject();
    return Properties === undefined ? result : defineProperties(result, Properties);
};

var wellKnownSymbol$d = wellKnownSymbol$e;
var create$2 = objectCreate;
var definePropertyModule$3 = objectDefineProperty;

var UNSCOPABLES = wellKnownSymbol$d('unscopables');
var ArrayPrototype$1 = Array.prototype;

// Array.prototype[@@unscopables]
// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
if (ArrayPrototype$1[UNSCOPABLES] == undefined) {
    definePropertyModule$3.f(ArrayPrototype$1, UNSCOPABLES, {
        configurable: true,
        value: create$2(null)
    });
}

// add a key to Array.prototype[@@unscopables]
var addToUnscopables$1 = function(key) {
    ArrayPrototype$1[UNSCOPABLES][key] = true;
};

var iterators = {};

var store$1 = sharedStore;

var functionToString = Function.toString;

// this helper broken in `3.4.1-3.4.4`, so we can't use `shared` helper
if (typeof store$1.inspectSource != 'function') {
    store$1.inspectSource = function(it) {
        return functionToString.call(it);
    };
}

var inspectSource$2 = store$1.inspectSource;

var global$a = global$h;
var inspectSource$1 = inspectSource$2;

var WeakMap$1 = global$a.WeakMap;

var nativeWeakMap = typeof WeakMap$1 === 'function' && /native code/.test(inspectSource$1(WeakMap$1));

var NATIVE_WEAK_MAP = nativeWeakMap;
var global$9 = global$h;
var isObject$5 = isObject$9;
var createNonEnumerableProperty$8 = createNonEnumerableProperty$a;
var objectHas = has$b;
var sharedKey$1 = sharedKey$3;
var hiddenKeys$1 = hiddenKeys$4;

var WeakMap = global$9.WeakMap;
var set$1, get$1, has$8;

var enforce = function(it) {
    return has$8(it) ? get$1(it) : set$1(it, {});
};

var getterFor = function(TYPE) {
    return function(it) {
        var state;
        if (!isObject$5(it) || (state = get$1(it)).type !== TYPE) {
            throw TypeError('Incompatible receiver, ' + TYPE + ' required');
        }
        return state;
    };
};

if (NATIVE_WEAK_MAP) {
    var store = new WeakMap();
    var wmget = store.get;
    var wmhas = store.has;
    var wmset = store.set;
    set$1 = function(it, metadata) {
        wmset.call(store, it, metadata);
        return metadata;
    };
    get$1 = function(it) {
        return wmget.call(store, it) || {};
    };
    has$8 = function(it) {
        return wmhas.call(store, it);
    };
} else {
    var STATE = sharedKey$1('state');
    hiddenKeys$1[STATE] = true;
    set$1 = function(it, metadata) {
        createNonEnumerableProperty$8(it, STATE, metadata);
        return metadata;
    };
    get$1 = function(it) {
        return objectHas(it, STATE) ? it[STATE] : {};
    };
    has$8 = function(it) {
        return objectHas(it, STATE);
    };
}

var internalState = {
    set: set$1,
    get: get$1,
    has: has$8,
    enforce: enforce,
    getterFor: getterFor
};

var objectGetOwnPropertyDescriptor = {};

var objectPropertyIsEnumerable = {};

var nativePropertyIsEnumerable = {}.propertyIsEnumerable;
var getOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

// Nashorn ~ JDK8 bug
var NASHORN_BUG = getOwnPropertyDescriptor$1 && !nativePropertyIsEnumerable.call({
    1: 2
}, 1);

// `Object.prototype.propertyIsEnumerable` method implementation
// https://tc39.github.io/ecma262/#sec-object.prototype.propertyisenumerable
objectPropertyIsEnumerable.f = NASHORN_BUG ? function propertyIsEnumerable(V) {
    var descriptor = getOwnPropertyDescriptor$1(this, V);
    return !!descriptor && descriptor.enumerable;
} : nativePropertyIsEnumerable;

var DESCRIPTORS$5 = descriptors;
var propertyIsEnumerableModule$1 = objectPropertyIsEnumerable;
var createPropertyDescriptor$2 = createPropertyDescriptor$4;
var toIndexedObject$1 = toIndexedObject$4;
var toPrimitive$1 = toPrimitive$3;
var has$7 = has$b;
var IE8_DOM_DEFINE = ie8DomDefine;

var nativeGetOwnPropertyDescriptor$1 = Object.getOwnPropertyDescriptor;

// `Object.getOwnPropertyDescriptor` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertydescriptor
objectGetOwnPropertyDescriptor.f = DESCRIPTORS$5 ? nativeGetOwnPropertyDescriptor$1 : function getOwnPropertyDescriptor(O, P) {
    O = toIndexedObject$1(O);
    P = toPrimitive$1(P, true);
    if (IE8_DOM_DEFINE) try {
        return nativeGetOwnPropertyDescriptor$1(O, P);
    } catch (error) { /* empty */ }
    if (has$7(O, P)) return createPropertyDescriptor$2(!propertyIsEnumerableModule$1.f.call(O, P), O[P]);
};

var redefine$5 = {
    exports: {}
};

var global$8 = global$h;
var createNonEnumerableProperty$7 = createNonEnumerableProperty$a;
var has$6 = has$b;
var setGlobal$1 = setGlobal$3;
var inspectSource = inspectSource$2;
var InternalStateModule$3 = internalState;

var getInternalState$3 = InternalStateModule$3.get;
var enforceInternalState = InternalStateModule$3.enforce;
var TEMPLATE = String(String).split('String');

(redefine$5.exports = function(O, key, value, options) {
    var unsafe = options ? !!options.unsafe : false;
    var simple = options ? !!options.enumerable : false;
    var noTargetGet = options ? !!options.noTargetGet : false;
    if (typeof value == 'function') {
        if (typeof key == 'string' && !has$6(value, 'name')) createNonEnumerableProperty$7(value, 'name', key);
        enforceInternalState(value).source = TEMPLATE.join(typeof key == 'string' ? key : '');
    }
    if (O === global$8) {
        if (simple) O[key] = value;
        else setGlobal$1(key, value);
        return;
    } else if (!unsafe) {
        delete O[key];
    } else if (!noTargetGet && O[key]) {
        simple = true;
    }
    if (simple) O[key] = value;
    else createNonEnumerableProperty$7(O, key, value);
    // add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, 'toString', function toString() {
    return typeof this == 'function' && getInternalState$3(this).source || inspectSource(this);
});

var objectGetOwnPropertyNames = {};

var internalObjectKeys = objectKeysInternal;
var enumBugKeys = enumBugKeys$3;

var hiddenKeys = enumBugKeys.concat('length', 'prototype');

// `Object.getOwnPropertyNames` method
// https://tc39.github.io/ecma262/#sec-object.getownpropertynames
objectGetOwnPropertyNames.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {
    return internalObjectKeys(O, hiddenKeys);
};

var objectGetOwnPropertySymbols = {};

objectGetOwnPropertySymbols.f = Object.getOwnPropertySymbols;

var getBuiltIn$1 = getBuiltIn$3;
var getOwnPropertyNamesModule = objectGetOwnPropertyNames;
var getOwnPropertySymbolsModule$1 = objectGetOwnPropertySymbols;
var anObject$5 = anObject$9;

// all object keys, includes non-enumerable and symbols
var ownKeys$1 = getBuiltIn$1('Reflect', 'ownKeys') || function ownKeys(it) {
    var keys = getOwnPropertyNamesModule.f(anObject$5(it));
    var getOwnPropertySymbols = getOwnPropertySymbolsModule$1.f;
    return getOwnPropertySymbols ? keys.concat(getOwnPropertySymbols(it)) : keys;
};

var has$5 = has$b;
var ownKeys = ownKeys$1;
var getOwnPropertyDescriptorModule$1 = objectGetOwnPropertyDescriptor;
var definePropertyModule$2 = objectDefineProperty;

var copyConstructorProperties$1 = function(target, source) {
    var keys = ownKeys(source);
    var defineProperty = definePropertyModule$2.f;
    var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule$1.f;
    for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        if (!has$5(target, key)) defineProperty(target, key, getOwnPropertyDescriptor(source, key));
    }
};

var fails$8 = fails$d;

var replacement = /#|\.prototype\./;

var isForced$1 = function(feature, detection) {
    var value = data[normalize(feature)];
    return value == POLYFILL ? true :
        value == NATIVE ? false :
        typeof detection == 'function' ? fails$8(detection) :
        !!detection;
};

var normalize = isForced$1.normalize = function(string) {
    return String(string).replace(replacement, '.').toLowerCase();
};

var data = isForced$1.data = {};
var NATIVE = isForced$1.NATIVE = 'N';
var POLYFILL = isForced$1.POLYFILL = 'P';

var isForced_1 = isForced$1;

var global$7 = global$h;
var getOwnPropertyDescriptor = objectGetOwnPropertyDescriptor.f;
var createNonEnumerableProperty$6 = createNonEnumerableProperty$a;
var redefine$4 = redefine$5.exports;
var setGlobal = setGlobal$3;
var copyConstructorProperties = copyConstructorProperties$1;
var isForced = isForced_1;

/*
  options.target      - name of the target object
  options.global      - target is the global object
  options.stat        - export as static methods of target
  options.proto       - export as prototype methods of target
  options.real        - real prototype method for the `pure` version
  options.forced      - export even if the native feature is available
  options.bind        - bind methods to the target, required for the `pure` version
  options.wrap        - wrap constructors to preventing global pollution, required for the `pure` version
  options.unsafe      - use the simple assignment of property instead of delete + defineProperty
  options.sham        - add a flag to not completely full polyfills
  options.enumerable  - export as enumerable property
  options.noTargetGet - prevent calling a getter on target
*/
var _export = function(options, source) {
    var TARGET = options.target;
    var GLOBAL = options.global;
    var STATIC = options.stat;
    var FORCED, target, key, targetProperty, sourceProperty, descriptor;
    if (GLOBAL) {
        target = global$7;
    } else if (STATIC) {
        target = global$7[TARGET] || setGlobal(TARGET, {});
    } else {
        target = (global$7[TARGET] || {}).prototype;
    }
    if (target)
        for (key in source) {
            sourceProperty = source[key];
            if (options.noTargetGet) {
                descriptor = getOwnPropertyDescriptor(target, key);
                targetProperty = descriptor && descriptor.value;
            } else targetProperty = target[key];
            FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);
            // contained in target
            if (!FORCED && targetProperty !== undefined) {
                if (typeof sourceProperty === typeof targetProperty) continue;
                copyConstructorProperties(sourceProperty, targetProperty);
            }
            // add a flag to not completely full polyfills
            if (options.sham || (targetProperty && targetProperty.sham)) {
                createNonEnumerableProperty$6(sourceProperty, 'sham', true);
            }
            // extend global
            redefine$4(target, key, sourceProperty, options);
        }
};

var requireObjectCoercible = requireObjectCoercible$2;

// `ToObject` abstract operation
// https://tc39.github.io/ecma262/#sec-toobject
var toObject$6 = function(argument) {
    return Object(requireObjectCoercible(argument));
};

var fails$7 = fails$d;

var correctPrototypeGetter = !fails$7(function() {
    function F() { /* empty */ }
    F.prototype.constructor = null;
    return Object.getPrototypeOf(new F()) !== F.prototype;
});

var has$4 = has$b;
var toObject$5 = toObject$6;
var sharedKey = sharedKey$3;
var CORRECT_PROTOTYPE_GETTER = correctPrototypeGetter;

var IE_PROTO = sharedKey('IE_PROTO');
var ObjectPrototype$2 = Object.prototype;

// `Object.getPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.getprototypeof
var objectGetPrototypeOf = CORRECT_PROTOTYPE_GETTER ? Object.getPrototypeOf : function(O) {
    O = toObject$5(O);
    if (has$4(O, IE_PROTO)) return O[IE_PROTO];
    if (typeof O.constructor == 'function' && O instanceof O.constructor) {
        return O.constructor.prototype;
    }
    return O instanceof Object ? ObjectPrototype$2 : null;
};

var getPrototypeOf$3 = objectGetPrototypeOf;
var createNonEnumerableProperty$5 = createNonEnumerableProperty$a;
var has$3 = has$b;
var wellKnownSymbol$c = wellKnownSymbol$e;

var ITERATOR$5 = wellKnownSymbol$c('iterator');
var BUGGY_SAFARI_ITERATORS$1 = false;

var returnThis$2 = function() {
    return this;
};

// `%IteratorPrototype%` object
// https://tc39.github.io/ecma262/#sec-%iteratorprototype%-object
var IteratorPrototype$2, PrototypeOfArrayIteratorPrototype, arrayIterator;

if ([].keys) {
    arrayIterator = [].keys();
    // Safari 8 has buggy iterators w/o `next`
    if (!('next' in arrayIterator)) BUGGY_SAFARI_ITERATORS$1 = true;
    else {
        PrototypeOfArrayIteratorPrototype = getPrototypeOf$3(getPrototypeOf$3(arrayIterator));
        if (PrototypeOfArrayIteratorPrototype !== Object.prototype) IteratorPrototype$2 = PrototypeOfArrayIteratorPrototype;
    }
}

if (IteratorPrototype$2 == undefined) IteratorPrototype$2 = {};

// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()
if (!has$3(IteratorPrototype$2, ITERATOR$5)) {
    createNonEnumerableProperty$5(IteratorPrototype$2, ITERATOR$5, returnThis$2);
}

var iteratorsCore = {
    IteratorPrototype: IteratorPrototype$2,
    BUGGY_SAFARI_ITERATORS: BUGGY_SAFARI_ITERATORS$1
};

var defineProperty$3 = objectDefineProperty.f;
var has$2 = has$b;
var wellKnownSymbol$b = wellKnownSymbol$e;

var TO_STRING_TAG$4 = wellKnownSymbol$b('toStringTag');

var setToStringTag$3 = function(it, TAG, STATIC) {
    if (it && !has$2(it = STATIC ? it : it.prototype, TO_STRING_TAG$4)) {
        defineProperty$3(it, TO_STRING_TAG$4, {
            configurable: true,
            value: TAG
        });
    }
};

var IteratorPrototype$1 = iteratorsCore.IteratorPrototype;
var create$1 = objectCreate;
var createPropertyDescriptor$1 = createPropertyDescriptor$4;
var setToStringTag$2 = setToStringTag$3;
var Iterators$4 = iterators;

var returnThis$1 = function() {
    return this;
};

var createIteratorConstructor$1 = function(IteratorConstructor, NAME, next) {
    var TO_STRING_TAG = NAME + ' Iterator';
    IteratorConstructor.prototype = create$1(IteratorPrototype$1, {
        next: createPropertyDescriptor$1(1, next)
    });
    setToStringTag$2(IteratorConstructor, TO_STRING_TAG, false);
    Iterators$4[TO_STRING_TAG] = returnThis$1;
    return IteratorConstructor;
};

var isObject$4 = isObject$9;

var aPossiblePrototype$1 = function(it) {
    if (!isObject$4(it) && it !== null) {
        throw TypeError("Can't set " + String(it) + ' as a prototype');
    }
    return it;
};

var anObject$4 = anObject$9;
var aPossiblePrototype = aPossiblePrototype$1;

// `Object.setPrototypeOf` method
// https://tc39.github.io/ecma262/#sec-object.setprototypeof
// Works with __proto__ only. Old v8 can't work with null proto objects.
/* eslint-disable no-proto */
var objectSetPrototypeOf = Object.setPrototypeOf || ('__proto__' in {} ? function() {
    var CORRECT_SETTER = false;
    var test = {};
    var setter;
    try {
        setter = Object.getOwnPropertyDescriptor(Object.prototype, '__proto__').set;
        setter.call(test, []);
        CORRECT_SETTER = test instanceof Array;
    } catch (error) { /* empty */ }
    return function setPrototypeOf(O, proto) {
        anObject$4(O);
        aPossiblePrototype(proto);
        if (CORRECT_SETTER) setter.call(O, proto);
        else O.__proto__ = proto;
        return O;
    };
}() : undefined);

var $$3 = _export;
var createIteratorConstructor = createIteratorConstructor$1;
var getPrototypeOf$2 = objectGetPrototypeOf;
var setPrototypeOf$4 = objectSetPrototypeOf;
var setToStringTag$1 = setToStringTag$3;
var createNonEnumerableProperty$4 = createNonEnumerableProperty$a;
var redefine$3 = redefine$5.exports;
var wellKnownSymbol$a = wellKnownSymbol$e;
var Iterators$3 = iterators;
var IteratorsCore = iteratorsCore;

var IteratorPrototype = IteratorsCore.IteratorPrototype;
var BUGGY_SAFARI_ITERATORS = IteratorsCore.BUGGY_SAFARI_ITERATORS;
var ITERATOR$4 = wellKnownSymbol$a('iterator');
var KEYS = 'keys';
var VALUES = 'values';
var ENTRIES = 'entries';

var returnThis = function() {
    return this;
};

var defineIterator$1 = function(Iterable, NAME, IteratorConstructor, next, DEFAULT, IS_SET, FORCED) {
    createIteratorConstructor(IteratorConstructor, NAME, next);

    var getIterationMethod = function(KIND) {
        if (KIND === DEFAULT && defaultIterator) return defaultIterator;
        if (!BUGGY_SAFARI_ITERATORS && KIND in IterablePrototype) return IterablePrototype[KIND];
        switch (KIND) {
            case KEYS:
                return function keys() {
                    return new IteratorConstructor(this, KIND);
                };
            case VALUES:
                return function values() {
                    return new IteratorConstructor(this, KIND);
                };
            case ENTRIES:
                return function entries() {
                    return new IteratorConstructor(this, KIND);
                };
        }
        return function() {
            return new IteratorConstructor(this);
        };
    };

    var TO_STRING_TAG = NAME + ' Iterator';
    var INCORRECT_VALUES_NAME = false;
    var IterablePrototype = Iterable.prototype;
    var nativeIterator = IterablePrototype[ITERATOR$4] ||
        IterablePrototype['@@iterator'] ||
        DEFAULT && IterablePrototype[DEFAULT];
    var defaultIterator = !BUGGY_SAFARI_ITERATORS && nativeIterator || getIterationMethod(DEFAULT);
    var anyNativeIterator = NAME == 'Array' ? IterablePrototype.entries || nativeIterator : nativeIterator;
    var CurrentIteratorPrototype, methods, KEY;

    // fix native
    if (anyNativeIterator) {
        CurrentIteratorPrototype = getPrototypeOf$2(anyNativeIterator.call(new Iterable()));
        if (IteratorPrototype !== Object.prototype && CurrentIteratorPrototype.next) {
            if (getPrototypeOf$2(CurrentIteratorPrototype) !== IteratorPrototype) {
                if (setPrototypeOf$4) {
                    setPrototypeOf$4(CurrentIteratorPrototype, IteratorPrototype);
                } else if (typeof CurrentIteratorPrototype[ITERATOR$4] != 'function') {
                    createNonEnumerableProperty$4(CurrentIteratorPrototype, ITERATOR$4, returnThis);
                }
            }
            // Set @@toStringTag to native iterators
            setToStringTag$1(CurrentIteratorPrototype, TO_STRING_TAG, true);
        }
    }

    // fix Array#{values, @@iterator}.name in V8 / FF
    if (DEFAULT == VALUES && nativeIterator && nativeIterator.name !== VALUES) {
        INCORRECT_VALUES_NAME = true;
        defaultIterator = function values() {
            return nativeIterator.call(this);
        };
    }

    // define iterator
    if (IterablePrototype[ITERATOR$4] !== defaultIterator) {
        createNonEnumerableProperty$4(IterablePrototype, ITERATOR$4, defaultIterator);
    }
    Iterators$3[NAME] = defaultIterator;

    // export additional methods
    if (DEFAULT) {
        methods = {
            values: getIterationMethod(VALUES),
            keys: IS_SET ? defaultIterator : getIterationMethod(KEYS),
            entries: getIterationMethod(ENTRIES)
        };
        if (FORCED)
            for (KEY in methods) {
                if (BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME || !(KEY in IterablePrototype)) {
                    redefine$3(IterablePrototype, KEY, methods[KEY]);
                }
            } else $$3({
                target: NAME,
                proto: true,
                forced: BUGGY_SAFARI_ITERATORS || INCORRECT_VALUES_NAME
            }, methods);
    }

    return methods;
};

var toIndexedObject = toIndexedObject$4;
var addToUnscopables = addToUnscopables$1;
var Iterators$2 = iterators;
var InternalStateModule$2 = internalState;
var defineIterator = defineIterator$1;

var ARRAY_ITERATOR = 'Array Iterator';
var setInternalState$2 = InternalStateModule$2.set;
var getInternalState$2 = InternalStateModule$2.getterFor(ARRAY_ITERATOR);

// `Array.prototype.entries` method
// https://tc39.github.io/ecma262/#sec-array.prototype.entries
// `Array.prototype.keys` method
// https://tc39.github.io/ecma262/#sec-array.prototype.keys
// `Array.prototype.values` method
// https://tc39.github.io/ecma262/#sec-array.prototype.values
// `Array.prototype[@@iterator]` method
// https://tc39.github.io/ecma262/#sec-array.prototype-@@iterator
// `CreateArrayIterator` internal method
// https://tc39.github.io/ecma262/#sec-createarrayiterator
var es_array_iterator = defineIterator(Array, 'Array', function(iterated, kind) {
    setInternalState$2(this, {
        type: ARRAY_ITERATOR,
        target: toIndexedObject(iterated), // target
        index: 0, // next index
        kind: kind // kind
    });
    // `%ArrayIteratorPrototype%.next` method
    // https://tc39.github.io/ecma262/#sec-%arrayiteratorprototype%.next
}, function() {
    var state = getInternalState$2(this);
    var target = state.target;
    var kind = state.kind;
    var index = state.index++;
    if (!target || index >= target.length) {
        state.target = undefined;
        return {
            value: undefined,
            done: true
        };
    }
    if (kind == 'keys') return {
        value: index,
        done: false
    };
    if (kind == 'values') return {
        value: target[index],
        done: false
    };
    return {
        value: [index, target[index]],
        done: false
    };
}, 'values');

// argumentsList[@@iterator] is %ArrayProto_values%
// https://tc39.github.io/ecma262/#sec-createunmappedargumentsobject
// https://tc39.github.io/ecma262/#sec-createmappedargumentsobject
Iterators$2.Arguments = Iterators$2.Array;

// https://tc39.github.io/ecma262/#sec-array.prototype-@@unscopables
addToUnscopables('keys');
addToUnscopables('values');
addToUnscopables('entries');

var arrayBufferNative = typeof ArrayBuffer !== 'undefined' && typeof DataView !== 'undefined';

var redefine$2 = redefine$5.exports;

var redefineAll$1 = function(target, src, options) {
    for (var key in src) redefine$2(target, key, src[key], options);
    return target;
};

var anInstance$2 = function(it, Constructor, name) {
    if (!(it instanceof Constructor)) {
        throw TypeError('Incorrect ' + (name ? name + ' ' : '') + 'invocation');
    }
    return it;
};

var toInteger$2 = toInteger$5;
var toLength$7 = toLength$9;

// `ToIndex` abstract operation
// https://tc39.github.io/ecma262/#sec-toindex
var toIndex$2 = function(it) {
    if (it === undefined) return 0;
    var number = toInteger$2(it);
    var length = toLength$7(number);
    if (number !== length) throw RangeError('Wrong length or index');
    return length;
};

// IEEE754 conversions based on https://github.com/feross/ieee754
// eslint-disable-next-line no-shadow-restricted-names
var Infinity = 1 / 0;
var abs = Math.abs;
var pow = Math.pow;
var floor = Math.floor;
var log = Math.log;
var LN2 = Math.LN2;

var pack = function(number, mantissaLength, bytes) {
    var buffer = new Array(bytes);
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var rt = mantissaLength === 23 ? pow(2, -24) - pow(2, -77) : 0;
    var sign = number < 0 || number === 0 && 1 / number < 0 ? 1 : 0;
    var index = 0;
    var exponent, mantissa, c;
    number = abs(number);
    // eslint-disable-next-line no-self-compare
    if (number != number || number === Infinity) {
        // eslint-disable-next-line no-self-compare
        mantissa = number != number ? 1 : 0;
        exponent = eMax;
    } else {
        exponent = floor(log(number) / LN2);
        if (number * (c = pow(2, -exponent)) < 1) {
            exponent--;
            c *= 2;
        }
        if (exponent + eBias >= 1) {
            number += rt / c;
        } else {
            number += rt * pow(2, 1 - eBias);
        }
        if (number * c >= 2) {
            exponent++;
            c /= 2;
        }
        if (exponent + eBias >= eMax) {
            mantissa = 0;
            exponent = eMax;
        } else if (exponent + eBias >= 1) {
            mantissa = (number * c - 1) * pow(2, mantissaLength);
            exponent = exponent + eBias;
        } else {
            mantissa = number * pow(2, eBias - 1) * pow(2, mantissaLength);
            exponent = 0;
        }
    }
    for (; mantissaLength >= 8; buffer[index++] = mantissa & 255, mantissa /= 256, mantissaLength -= 8);
    exponent = exponent << mantissaLength | mantissa;
    exponentLength += mantissaLength;
    for (; exponentLength > 0; buffer[index++] = exponent & 255, exponent /= 256, exponentLength -= 8);
    buffer[--index] |= sign * 128;
    return buffer;
};

var unpack = function(buffer, mantissaLength) {
    var bytes = buffer.length;
    var exponentLength = bytes * 8 - mantissaLength - 1;
    var eMax = (1 << exponentLength) - 1;
    var eBias = eMax >> 1;
    var nBits = exponentLength - 7;
    var index = bytes - 1;
    var sign = buffer[index--];
    var exponent = sign & 127;
    var mantissa;
    sign >>= 7;
    for (; nBits > 0; exponent = exponent * 256 + buffer[index], index--, nBits -= 8);
    mantissa = exponent & (1 << -nBits) - 1;
    exponent >>= -nBits;
    nBits += mantissaLength;
    for (; nBits > 0; mantissa = mantissa * 256 + buffer[index], index--, nBits -= 8);
    if (exponent === 0) {
        exponent = 1 - eBias;
    } else if (exponent === eMax) {
        return mantissa ? NaN : sign ? -Infinity : Infinity;
    } else {
        mantissa = mantissa + pow(2, mantissaLength);
        exponent = exponent - eBias;
    }
    return (sign ? -1 : 1) * mantissa * pow(2, exponent - mantissaLength);
};

var ieee754 = {
    pack: pack,
    unpack: unpack
};

var toObject$4 = toObject$6;
var toAbsoluteIndex$1 = toAbsoluteIndex$3;
var toLength$6 = toLength$9;

// `Array.prototype.fill` method implementation
// https://tc39.github.io/ecma262/#sec-array.prototype.fill
var arrayFill$1 = function fill(value /* , start = 0, end = @length */ ) {
    var O = toObject$4(this);
    var length = toLength$6(O.length);
    var argumentsLength = arguments.length;
    var index = toAbsoluteIndex$1(argumentsLength > 1 ? arguments[1] : undefined, length);
    var end = argumentsLength > 2 ? arguments[2] : undefined;
    var endPos = end === undefined ? length : toAbsoluteIndex$1(end, length);
    while (endPos > index) O[index++] = value;
    return O;
};

var global$6 = global$h;
var DESCRIPTORS$4 = descriptors;
var NATIVE_ARRAY_BUFFER$1 = arrayBufferNative;
var createNonEnumerableProperty$3 = createNonEnumerableProperty$a;
var redefineAll = redefineAll$1;
var fails$6 = fails$d;
var anInstance$1 = anInstance$2;
var toInteger$1 = toInteger$5;
var toLength$5 = toLength$9;
var toIndex$1 = toIndex$2;
var IEEE754 = ieee754;
var getPrototypeOf$1 = objectGetPrototypeOf;
var setPrototypeOf$3 = objectSetPrototypeOf;
var getOwnPropertyNames$1 = objectGetOwnPropertyNames.f;
var defineProperty$2 = objectDefineProperty.f;
var arrayFill = arrayFill$1;
var setToStringTag = setToStringTag$3;
var InternalStateModule$1 = internalState;

var getInternalState$1 = InternalStateModule$1.get;
var setInternalState$1 = InternalStateModule$1.set;
var ARRAY_BUFFER = 'ArrayBuffer';
var DATA_VIEW = 'DataView';
var PROTOTYPE = 'prototype';
var WRONG_LENGTH$1 = 'Wrong length';
var WRONG_INDEX = 'Wrong index';
var NativeArrayBuffer = global$6[ARRAY_BUFFER];
var $ArrayBuffer = NativeArrayBuffer;
var $DataView = global$6[DATA_VIEW];
var $DataViewPrototype = $DataView && $DataView[PROTOTYPE];
var ObjectPrototype$1 = Object.prototype;
var RangeError$2 = global$6.RangeError;

var packIEEE754 = IEEE754.pack;
var unpackIEEE754 = IEEE754.unpack;

var packInt8 = function(number) {
    return [number & 0xFF];
};

var packInt16 = function(number) {
    return [number & 0xFF, number >> 8 & 0xFF];
};

var packInt32 = function(number) {
    return [number & 0xFF, number >> 8 & 0xFF, number >> 16 & 0xFF, number >> 24 & 0xFF];
};

var unpackInt32 = function(buffer) {
    return buffer[3] << 24 | buffer[2] << 16 | buffer[1] << 8 | buffer[0];
};

var packFloat32 = function(number) {
    return packIEEE754(number, 23, 4);
};

var packFloat64 = function(number) {
    return packIEEE754(number, 52, 8);
};

var addGetter$1 = function(Constructor, key) {
    defineProperty$2(Constructor[PROTOTYPE], key, {
        get: function() {
            return getInternalState$1(this)[key];
        }
    });
};

var get = function(view, count, index, isLittleEndian) {
    var intIndex = toIndex$1(index);
    var store = getInternalState$1(view);
    if (intIndex + count > store.byteLength) throw RangeError$2(WRONG_INDEX);
    var bytes = getInternalState$1(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = bytes.slice(start, start + count);
    return isLittleEndian ? pack : pack.reverse();
};

var set = function(view, count, index, conversion, value, isLittleEndian) {
    var intIndex = toIndex$1(index);
    var store = getInternalState$1(view);
    if (intIndex + count > store.byteLength) throw RangeError$2(WRONG_INDEX);
    var bytes = getInternalState$1(store.buffer).bytes;
    var start = intIndex + store.byteOffset;
    var pack = conversion(+value);
    for (var i = 0; i < count; i++) bytes[start + i] = pack[isLittleEndian ? i : count - i - 1];
};

if (!NATIVE_ARRAY_BUFFER$1) {
    $ArrayBuffer = function ArrayBuffer(length) {
        anInstance$1(this, $ArrayBuffer, ARRAY_BUFFER);
        var byteLength = toIndex$1(length);
        setInternalState$1(this, {
            bytes: arrayFill.call(new Array(byteLength), 0),
            byteLength: byteLength
        });
        if (!DESCRIPTORS$4) this.byteLength = byteLength;
    };

    $DataView = function DataView(buffer, byteOffset, byteLength) {
        anInstance$1(this, $DataView, DATA_VIEW);
        anInstance$1(buffer, $ArrayBuffer, DATA_VIEW);
        var bufferLength = getInternalState$1(buffer).byteLength;
        var offset = toInteger$1(byteOffset);
        if (offset < 0 || offset > bufferLength) throw RangeError$2('Wrong offset');
        byteLength = byteLength === undefined ? bufferLength - offset : toLength$5(byteLength);
        if (offset + byteLength > bufferLength) throw RangeError$2(WRONG_LENGTH$1);
        setInternalState$1(this, {
            buffer: buffer,
            byteLength: byteLength,
            byteOffset: offset
        });
        if (!DESCRIPTORS$4) {
            this.buffer = buffer;
            this.byteLength = byteLength;
            this.byteOffset = offset;
        }
    };

    if (DESCRIPTORS$4) {
        addGetter$1($ArrayBuffer, 'byteLength');
        addGetter$1($DataView, 'buffer');
        addGetter$1($DataView, 'byteLength');
        addGetter$1($DataView, 'byteOffset');
    }

    redefineAll($DataView[PROTOTYPE], {
        getInt8: function getInt8(byteOffset) {
            return get(this, 1, byteOffset)[0] << 24 >> 24;
        },
        getUint8: function getUint8(byteOffset) {
            return get(this, 1, byteOffset)[0];
        },
        getInt16: function getInt16(byteOffset /* , littleEndian */ ) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
            return (bytes[1] << 8 | bytes[0]) << 16 >> 16;
        },
        getUint16: function getUint16(byteOffset /* , littleEndian */ ) {
            var bytes = get(this, 2, byteOffset, arguments.length > 1 ? arguments[1] : undefined);
            return bytes[1] << 8 | bytes[0];
        },
        getInt32: function getInt32(byteOffset /* , littleEndian */ ) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined));
        },
        getUint32: function getUint32(byteOffset /* , littleEndian */ ) {
            return unpackInt32(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined)) >>> 0;
        },
        getFloat32: function getFloat32(byteOffset /* , littleEndian */ ) {
            return unpackIEEE754(get(this, 4, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 23);
        },
        getFloat64: function getFloat64(byteOffset /* , littleEndian */ ) {
            return unpackIEEE754(get(this, 8, byteOffset, arguments.length > 1 ? arguments[1] : undefined), 52);
        },
        setInt8: function setInt8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
        },
        setUint8: function setUint8(byteOffset, value) {
            set(this, 1, byteOffset, packInt8, value);
        },
        setInt16: function setInt16(byteOffset, value /* , littleEndian */ ) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setUint16: function setUint16(byteOffset, value /* , littleEndian */ ) {
            set(this, 2, byteOffset, packInt16, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setInt32: function setInt32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setUint32: function setUint32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packInt32, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setFloat32: function setFloat32(byteOffset, value /* , littleEndian */ ) {
            set(this, 4, byteOffset, packFloat32, value, arguments.length > 2 ? arguments[2] : undefined);
        },
        setFloat64: function setFloat64(byteOffset, value /* , littleEndian */ ) {
            set(this, 8, byteOffset, packFloat64, value, arguments.length > 2 ? arguments[2] : undefined);
        }
    });
} else {
    if (!fails$6(function() {
            NativeArrayBuffer(1);
        }) || !fails$6(function() {
            new NativeArrayBuffer(-1); // eslint-disable-line no-new
        }) || fails$6(function() {
            new NativeArrayBuffer(); // eslint-disable-line no-new
            new NativeArrayBuffer(1.5); // eslint-disable-line no-new
            new NativeArrayBuffer(NaN); // eslint-disable-line no-new
            return NativeArrayBuffer.name != ARRAY_BUFFER;
        })) {
        $ArrayBuffer = function ArrayBuffer(length) {
            anInstance$1(this, $ArrayBuffer);
            return new NativeArrayBuffer(toIndex$1(length));
        };
        var ArrayBufferPrototype = $ArrayBuffer[PROTOTYPE] = NativeArrayBuffer[PROTOTYPE];
        for (var keys = getOwnPropertyNames$1(NativeArrayBuffer), j = 0, key; keys.length > j;) {
            if (!((key = keys[j++]) in $ArrayBuffer)) {
                createNonEnumerableProperty$3($ArrayBuffer, key, NativeArrayBuffer[key]);
            }
        }
        ArrayBufferPrototype.constructor = $ArrayBuffer;
    }

    // WebKit bug - the same parent prototype for typed arrays and data view
    if (setPrototypeOf$3 && getPrototypeOf$1($DataViewPrototype) !== ObjectPrototype$1) {
        setPrototypeOf$3($DataViewPrototype, ObjectPrototype$1);
    }

    // iOS Safari 7.x bug
    var testView = new $DataView(new $ArrayBuffer(2));
    var nativeSetInt8 = $DataViewPrototype.setInt8;
    testView.setInt8(0, 2147483648);
    testView.setInt8(1, 2147483649);
    if (testView.getInt8(0) || !testView.getInt8(1)) redefineAll($DataViewPrototype, {
        setInt8: function setInt8(byteOffset, value) {
            nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
        },
        setUint8: function setUint8(byteOffset, value) {
            nativeSetInt8.call(this, byteOffset, value << 24 >> 24);
        }
    }, {
        unsafe: true
    });
}

setToStringTag($ArrayBuffer, ARRAY_BUFFER);
setToStringTag($DataView, DATA_VIEW);

var arrayBuffer = {
    ArrayBuffer: $ArrayBuffer,
    DataView: $DataView
};

var aFunction$2 = function(it) {
    if (typeof it != 'function') {
        throw TypeError(String(it) + ' is not a function');
    }
    return it;
};

var anObject$3 = anObject$9;
var aFunction$1 = aFunction$2;
var wellKnownSymbol$9 = wellKnownSymbol$e;

var SPECIES$2 = wellKnownSymbol$9('species');

// `SpeciesConstructor` abstract operation
// https://tc39.github.io/ecma262/#sec-speciesconstructor
var speciesConstructor$1 = function(O, defaultConstructor) {
    var C = anObject$3(O).constructor;
    var S;
    return C === undefined || (S = anObject$3(C)[SPECIES$2]) == undefined ? defaultConstructor : aFunction$1(S);
};

var $$2 = _export;
var fails$5 = fails$d;
var ArrayBufferModule$1 = arrayBuffer;
var anObject$2 = anObject$9;
var toAbsoluteIndex = toAbsoluteIndex$3;
var toLength$4 = toLength$9;
var speciesConstructor = speciesConstructor$1;

var ArrayBuffer$3 = ArrayBufferModule$1.ArrayBuffer;
var DataView$2 = ArrayBufferModule$1.DataView;
var nativeArrayBufferSlice = ArrayBuffer$3.prototype.slice;

var INCORRECT_SLICE = fails$5(function() {
    return !new ArrayBuffer$3(2).slice(1, undefined).byteLength;
});

// `ArrayBuffer.prototype.slice` method
// https://tc39.github.io/ecma262/#sec-arraybuffer.prototype.slice
$$2({
    target: 'ArrayBuffer',
    proto: true,
    unsafe: true,
    forced: INCORRECT_SLICE
}, {
    slice: function slice(start, end) {
        if (nativeArrayBufferSlice !== undefined && end === undefined) {
            return nativeArrayBufferSlice.call(anObject$2(this), start); // FF fix
        }
        var length = anObject$2(this).byteLength;
        var first = toAbsoluteIndex(start, length);
        var fin = toAbsoluteIndex(end === undefined ? length : end, length);
        var result = new(speciesConstructor(this, ArrayBuffer$3))(toLength$4(fin - first));
        var viewSource = new DataView$2(this);
        var viewTarget = new DataView$2(result);
        var index = 0;
        while (first < fin) {
            viewTarget.setUint8(index++, viewSource.getUint8(first++));
        }
        return result;
    }
});

var DESCRIPTORS$3 = descriptors;
var fails$4 = fails$d;
var objectKeys = objectKeys$2;
var getOwnPropertySymbolsModule = objectGetOwnPropertySymbols;
var propertyIsEnumerableModule = objectPropertyIsEnumerable;
var toObject$3 = toObject$6;
var IndexedObject$1 = indexedObject;

var nativeAssign = Object.assign;
var defineProperty$1 = Object.defineProperty;

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
var objectAssign = !nativeAssign || fails$4(function() {
    // should have correct order of operations (Edge bug)
    if (DESCRIPTORS$3 && nativeAssign({
            b: 1
        }, nativeAssign(defineProperty$1({}, 'a', {
            enumerable: true,
            get: function() {
                defineProperty$1(this, 'b', {
                    value: 3,
                    enumerable: false
                });
            }
        }), {
            b: 2
        })).b !== 1) return true;
    // should work with symbols and should have deterministic property order (V8 bug)
    var A = {};
    var B = {};
    // eslint-disable-next-line no-undef
    var symbol = Symbol();
    var alphabet = 'abcdefghijklmnopqrst';
    A[symbol] = 7;
    alphabet.split('').forEach(function(chr) {
        B[chr] = chr;
    });
    return nativeAssign({}, A)[symbol] != 7 || objectKeys(nativeAssign({}, B)).join('') != alphabet;
}) ? function assign(target, source) { // eslint-disable-line no-unused-vars
    var T = toObject$3(target);
    var argumentsLength = arguments.length;
    var index = 1;
    var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;
    var propertyIsEnumerable = propertyIsEnumerableModule.f;
    while (argumentsLength > index) {
        var S = IndexedObject$1(arguments[index++]);
        var keys = getOwnPropertySymbols ? objectKeys(S).concat(getOwnPropertySymbols(S)) : objectKeys(S);
        var length = keys.length;
        var j = 0;
        var key;
        while (length > j) {
            key = keys[j++];
            if (!DESCRIPTORS$3 || propertyIsEnumerable.call(S, key)) T[key] = S[key];
        }
    }
    return T;
} : nativeAssign;

var $$1 = _export;
var assign = objectAssign;

// `Object.assign` method
// https://tc39.github.io/ecma262/#sec-object.assign
$$1({
    target: 'Object',
    stat: true,
    forced: Object.assign !== assign
}, {
    assign: assign
});

var anObject$1 = anObject$9;

// `RegExp.prototype.flags` getter implementation
// https://tc39.github.io/ecma262/#sec-get-regexp.prototype.flags
var regexpFlags = function() {
    var that = anObject$1(this);
    var result = '';
    if (that.global) result += 'g';
    if (that.ignoreCase) result += 'i';
    if (that.multiline) result += 'm';
    if (that.dotAll) result += 's';
    if (that.unicode) result += 'u';
    if (that.sticky) result += 'y';
    return result;
};

var redefine$1 = redefine$5.exports;
var anObject = anObject$9;
var fails$3 = fails$d;
var flags = regexpFlags;

var TO_STRING = 'toString';
var RegExpPrototype = RegExp.prototype;
var nativeToString = RegExpPrototype[TO_STRING];

var NOT_GENERIC = fails$3(function() {
    return nativeToString.call({
        source: 'a',
        flags: 'b'
    }) != '/a/b';
});
// FF44- RegExp#toString has a wrong name
var INCORRECT_NAME = nativeToString.name != TO_STRING;

// `RegExp.prototype.toString` method
// https://tc39.github.io/ecma262/#sec-regexp.prototype.tostring
if (NOT_GENERIC || INCORRECT_NAME) {
    redefine$1(RegExp.prototype, TO_STRING, function toString() {
        var R = anObject(this);
        var p = String(R.source);
        var rf = R.flags;
        var f = String(rf === undefined && R instanceof RegExp && !('flags' in RegExpPrototype) ? flags.call(R) : rf);
        return '/' + p + '/' + f;
    }, {
        unsafe: true
    });
}

var typedArrayConstructor = {
    exports: {}
};

var wellKnownSymbol$8 = wellKnownSymbol$e;

var ITERATOR$3 = wellKnownSymbol$8('iterator');
var SAFE_CLOSING = false;

try {
    var called = 0;
    var iteratorWithReturn = {
        next: function() {
            return {
                done: !!called++
            };
        },
        'return': function() {
            SAFE_CLOSING = true;
        }
    };
    iteratorWithReturn[ITERATOR$3] = function() {
        return this;
    };
    // eslint-disable-next-line no-throw-literal
    Array.from(iteratorWithReturn, function() {
        throw 2;
    });
} catch (error) { /* empty */ }

var checkCorrectnessOfIteration$1 = function(exec, SKIP_CLOSING) {
    if (!SKIP_CLOSING && !SAFE_CLOSING) return false;
    var ITERATION_SUPPORT = false;
    try {
        var object = {};
        object[ITERATOR$3] = function() {
            return {
                next: function() {
                    return {
                        done: ITERATION_SUPPORT = true
                    };
                }
            };
        };
        exec(object);
    } catch (error) { /* empty */ }
    return ITERATION_SUPPORT;
};

var wellKnownSymbol$7 = wellKnownSymbol$e;

var TO_STRING_TAG$3 = wellKnownSymbol$7('toStringTag');
var test = {};

test[TO_STRING_TAG$3] = 'z';

var toStringTagSupport = String(test) === '[object z]';

var TO_STRING_TAG_SUPPORT = toStringTagSupport;
var classofRaw = classofRaw$1;
var wellKnownSymbol$6 = wellKnownSymbol$e;

var TO_STRING_TAG$2 = wellKnownSymbol$6('toStringTag');
// ES3 wrong here
var CORRECT_ARGUMENTS = classofRaw(function() {
    return arguments;
}()) == 'Arguments';

// fallback for IE11 Script Access Denied error
var tryGet = function(it, key) {
    try {
        return it[key];
    } catch (error) { /* empty */ }
};

// getting tag from ES6+ `Object.prototype.toString`
var classof$4 = TO_STRING_TAG_SUPPORT ? classofRaw : function(it) {
    var O, tag, result;
    return it === undefined ? 'Undefined' : it === null ? 'Null'
        // @@toStringTag case
        :
        typeof(tag = tryGet(O = Object(it), TO_STRING_TAG$2)) == 'string' ? tag
        // builtinTag case
        :
        CORRECT_ARGUMENTS ? classofRaw(O)
        // ES3 arguments fallback
        :
        (result = classofRaw(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : result;
};

var NATIVE_ARRAY_BUFFER = arrayBufferNative;
var DESCRIPTORS$2 = descriptors;
var global$5 = global$h;
var isObject$3 = isObject$9;
var has$1 = has$b;
var classof$3 = classof$4;
var createNonEnumerableProperty$2 = createNonEnumerableProperty$a;
var redefine = redefine$5.exports;
var defineProperty = objectDefineProperty.f;
var getPrototypeOf = objectGetPrototypeOf;
var setPrototypeOf$2 = objectSetPrototypeOf;
var wellKnownSymbol$5 = wellKnownSymbol$e;
var uid = uid$3;

var Int8Array$3 = global$5.Int8Array;
var Int8ArrayPrototype = Int8Array$3 && Int8Array$3.prototype;
var Uint8ClampedArray = global$5.Uint8ClampedArray;
var Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;
var TypedArray$1 = Int8Array$3 && getPrototypeOf(Int8Array$3);
var TypedArrayPrototype$1 = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);
var ObjectPrototype = Object.prototype;
var isPrototypeOf = ObjectPrototype.isPrototypeOf;

var TO_STRING_TAG$1 = wellKnownSymbol$5('toStringTag');
var TYPED_ARRAY_TAG$1 = uid('TYPED_ARRAY_TAG');
// Fixing native typed arrays in Opera Presto crashes the browser, see #595
var NATIVE_ARRAY_BUFFER_VIEWS$2 = NATIVE_ARRAY_BUFFER && !!setPrototypeOf$2 && classof$3(global$5.opera) !== 'Opera';
var TYPED_ARRAY_TAG_REQIRED = false;
var NAME;

var TypedArrayConstructorsList = {
    Int8Array: 1,
    Uint8Array: 1,
    Uint8ClampedArray: 1,
    Int16Array: 2,
    Uint16Array: 2,
    Int32Array: 4,
    Uint32Array: 4,
    Float32Array: 4,
    Float64Array: 8
};

var isView = function isView(it) {
    var klass = classof$3(it);
    return klass === 'DataView' || has$1(TypedArrayConstructorsList, klass);
};

var isTypedArray$1 = function(it) {
    return isObject$3(it) && has$1(TypedArrayConstructorsList, classof$3(it));
};

var aTypedArray$4 = function(it) {
    if (isTypedArray$1(it)) return it;
    throw TypeError('Target is not a typed array');
};

var aTypedArrayConstructor$2 = function(C) {
    if (setPrototypeOf$2) {
        if (isPrototypeOf.call(TypedArray$1, C)) return C;
    } else
        for (var ARRAY in TypedArrayConstructorsList)
            if (has$1(TypedArrayConstructorsList, NAME)) {
                var TypedArrayConstructor = global$5[ARRAY];
                if (TypedArrayConstructor && (C === TypedArrayConstructor || isPrototypeOf.call(TypedArrayConstructor, C))) {
                    return C;
                }
            } throw TypeError('Target is not a typed array constructor');
};

var exportTypedArrayMethod$4 = function(KEY, property, forced) {
    if (!DESCRIPTORS$2) return;
    if (forced)
        for (var ARRAY in TypedArrayConstructorsList) {
            var TypedArrayConstructor = global$5[ARRAY];
            if (TypedArrayConstructor && has$1(TypedArrayConstructor.prototype, KEY)) {
                delete TypedArrayConstructor.prototype[KEY];
            }
        }
    if (!TypedArrayPrototype$1[KEY] || forced) {
        redefine(TypedArrayPrototype$1, KEY, forced ? property :
            NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8ArrayPrototype[KEY] || property);
    }
};

var exportTypedArrayStaticMethod = function(KEY, property, forced) {
    var ARRAY, TypedArrayConstructor;
    if (!DESCRIPTORS$2) return;
    if (setPrototypeOf$2) {
        if (forced)
            for (ARRAY in TypedArrayConstructorsList) {
                TypedArrayConstructor = global$5[ARRAY];
                if (TypedArrayConstructor && has$1(TypedArrayConstructor, KEY)) {
                    delete TypedArrayConstructor[KEY];
                }
            }
        if (!TypedArray$1[KEY] || forced) {
            // V8 ~ Chrome 49-50 `%TypedArray%` methods are non-writable non-configurable
            try {
                return redefine(TypedArray$1, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS$2 && Int8Array$3[KEY] || property);
            } catch (error) { /* empty */ }
        } else return;
    }
    for (ARRAY in TypedArrayConstructorsList) {
        TypedArrayConstructor = global$5[ARRAY];
        if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {
            redefine(TypedArrayConstructor, KEY, property);
        }
    }
};

for (NAME in TypedArrayConstructorsList) {
    if (!global$5[NAME]) NATIVE_ARRAY_BUFFER_VIEWS$2 = false;
}

// WebKit bug - typed arrays constructors prototype is Object.prototype
if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || typeof TypedArray$1 != 'function' || TypedArray$1 === Function.prototype) {
    // eslint-disable-next-line no-shadow
    TypedArray$1 = function TypedArray() {
        throw TypeError('Incorrect invocation');
    };
    if (NATIVE_ARRAY_BUFFER_VIEWS$2)
        for (NAME in TypedArrayConstructorsList) {
            if (global$5[NAME]) setPrototypeOf$2(global$5[NAME], TypedArray$1);
        }
}

if (!NATIVE_ARRAY_BUFFER_VIEWS$2 || !TypedArrayPrototype$1 || TypedArrayPrototype$1 === ObjectPrototype) {
    TypedArrayPrototype$1 = TypedArray$1.prototype;
    if (NATIVE_ARRAY_BUFFER_VIEWS$2)
        for (NAME in TypedArrayConstructorsList) {
            if (global$5[NAME]) setPrototypeOf$2(global$5[NAME].prototype, TypedArrayPrototype$1);
        }
}

// WebKit bug - one more object in Uint8ClampedArray prototype chain
if (NATIVE_ARRAY_BUFFER_VIEWS$2 && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype$1) {
    setPrototypeOf$2(Uint8ClampedArrayPrototype, TypedArrayPrototype$1);
}

if (DESCRIPTORS$2 && !has$1(TypedArrayPrototype$1, TO_STRING_TAG$1)) {
    TYPED_ARRAY_TAG_REQIRED = true;
    defineProperty(TypedArrayPrototype$1, TO_STRING_TAG$1, {
        get: function() {
            return isObject$3(this) ? this[TYPED_ARRAY_TAG$1] : undefined;
        }
    });
    for (NAME in TypedArrayConstructorsList)
        if (global$5[NAME]) {
            createNonEnumerableProperty$2(global$5[NAME], TYPED_ARRAY_TAG$1, NAME);
        }
}

var arrayBufferViewCore = {
    NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS$2,
    TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQIRED && TYPED_ARRAY_TAG$1,
    aTypedArray: aTypedArray$4,
    aTypedArrayConstructor: aTypedArrayConstructor$2,
    exportTypedArrayMethod: exportTypedArrayMethod$4,
    exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,
    isView: isView,
    isTypedArray: isTypedArray$1,
    TypedArray: TypedArray$1,
    TypedArrayPrototype: TypedArrayPrototype$1
};

/* eslint-disable no-new */

var global$4 = global$h;
var fails$2 = fails$d;
var checkCorrectnessOfIteration = checkCorrectnessOfIteration$1;
var NATIVE_ARRAY_BUFFER_VIEWS$1 = arrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS;

var ArrayBuffer$2 = global$4.ArrayBuffer;
var Int8Array$2 = global$4.Int8Array;

var typedArrayConstructorsRequireWrappers = !NATIVE_ARRAY_BUFFER_VIEWS$1 || !fails$2(function() {
    Int8Array$2(1);
}) || !fails$2(function() {
    new Int8Array$2(-1);
}) || !checkCorrectnessOfIteration(function(iterable) {
    new Int8Array$2();
    new Int8Array$2(null);
    new Int8Array$2(1.5);
    new Int8Array$2(iterable);
}, true) || fails$2(function() {
    // Safari (11+) bug - a reason why even Safari 13 should load a typed array polyfill
    return new Int8Array$2(new ArrayBuffer$2(2), 1, undefined).length !== 1;
});

var toInteger = toInteger$5;

var toPositiveInteger$1 = function(it) {
    var result = toInteger(it);
    if (result < 0) throw RangeError("The argument can't be less than 0");
    return result;
};

var toPositiveInteger = toPositiveInteger$1;

var toOffset$2 = function(it, BYTES) {
    var offset = toPositiveInteger(it);
    if (offset % BYTES) throw RangeError('Wrong offset');
    return offset;
};

var classof$2 = classof$4;
var Iterators$1 = iterators;
var wellKnownSymbol$4 = wellKnownSymbol$e;

var ITERATOR$2 = wellKnownSymbol$4('iterator');

var getIteratorMethod$1 = function(it) {
    if (it != undefined) return it[ITERATOR$2] ||
        it['@@iterator'] ||
        Iterators$1[classof$2(it)];
};

var wellKnownSymbol$3 = wellKnownSymbol$e;
var Iterators = iterators;

var ITERATOR$1 = wellKnownSymbol$3('iterator');
var ArrayPrototype = Array.prototype;

// check on default Array iterator
var isArrayIteratorMethod$1 = function(it) {
    return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR$1] === it);
};

var aFunction = aFunction$2;

// optional / simple context binding
var functionBindContext = function(fn, that, length) {
    aFunction(fn);
    if (that === undefined) return fn;
    switch (length) {
        case 0:
            return function() {
                return fn.call(that);
            };
        case 1:
            return function(a) {
                return fn.call(that, a);
            };
        case 2:
            return function(a, b) {
                return fn.call(that, a, b);
            };
        case 3:
            return function(a, b, c) {
                return fn.call(that, a, b, c);
            };
    }
    return function( /* ...args */ ) {
        return fn.apply(that, arguments);
    };
};

var toObject$2 = toObject$6;
var toLength$3 = toLength$9;
var getIteratorMethod = getIteratorMethod$1;
var isArrayIteratorMethod = isArrayIteratorMethod$1;
var bind$1 = functionBindContext;
var aTypedArrayConstructor$1 = arrayBufferViewCore.aTypedArrayConstructor;

var typedArrayFrom$1 = function from(source /* , mapfn, thisArg */ ) {
    var O = toObject$2(source);
    var argumentsLength = arguments.length;
    var mapfn = argumentsLength > 1 ? arguments[1] : undefined;
    var mapping = mapfn !== undefined;
    var iteratorMethod = getIteratorMethod(O);
    var i, length, result, step, iterator, next;
    if (iteratorMethod != undefined && !isArrayIteratorMethod(iteratorMethod)) {
        iterator = iteratorMethod.call(O);
        next = iterator.next;
        O = [];
        while (!(step = next.call(iterator)).done) {
            O.push(step.value);
        }
    }
    if (mapping && argumentsLength > 2) {
        mapfn = bind$1(mapfn, arguments[2], 2);
    }
    length = toLength$3(O.length);
    result = new(aTypedArrayConstructor$1(this))(length);
    for (i = 0; length > i; i++) {
        result[i] = mapping ? mapfn(O[i], i) : O[i];
    }
    return result;
};

var classof$1 = classofRaw$1;

// `IsArray` abstract operation
// https://tc39.github.io/ecma262/#sec-isarray
var isArray$1 = Array.isArray || function isArray(arg) {
    return classof$1(arg) == 'Array';
};

var isObject$2 = isObject$9;
var isArray = isArray$1;
var wellKnownSymbol$2 = wellKnownSymbol$e;

var SPECIES$1 = wellKnownSymbol$2('species');

// `ArraySpeciesCreate` abstract operation
// https://tc39.github.io/ecma262/#sec-arrayspeciescreate
var arraySpeciesCreate$1 = function(originalArray, length) {
    var C;
    if (isArray(originalArray)) {
        C = originalArray.constructor;
        // cross-realm fallback
        if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;
        else if (isObject$2(C)) {
            C = C[SPECIES$1];
            if (C === null) C = undefined;
        }
    }
    return new(C === undefined ? Array : C)(length === 0 ? 0 : length);
};

var bind = functionBindContext;
var IndexedObject = indexedObject;
var toObject$1 = toObject$6;
var toLength$2 = toLength$9;
var arraySpeciesCreate = arraySpeciesCreate$1;

var push = [].push;

// `Array.prototype.{ forEach, map, filter, some, every, find, findIndex }` methods implementation
var createMethod = function(TYPE) {
    var IS_MAP = TYPE == 1;
    var IS_FILTER = TYPE == 2;
    var IS_SOME = TYPE == 3;
    var IS_EVERY = TYPE == 4;
    var IS_FIND_INDEX = TYPE == 6;
    var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;
    return function($this, callbackfn, that, specificCreate) {
        var O = toObject$1($this);
        var self = IndexedObject(O);
        var boundFunction = bind(callbackfn, that, 3);
        var length = toLength$2(self.length);
        var index = 0;
        var create = specificCreate || arraySpeciesCreate;
        var target = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;
        var value, result;
        for (; length > index; index++)
            if (NO_HOLES || index in self) {
                value = self[index];
                result = boundFunction(value, index, O);
                if (TYPE) {
                    if (IS_MAP) target[index] = result; // map
                    else if (result) switch (TYPE) {
                        case 3:
                            return true; // some
                        case 5:
                            return value; // find
                        case 6:
                            return index; // findIndex
                        case 2:
                            push.call(target, value); // filter
                    } else if (IS_EVERY) return false; // every
                }
            }
        return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : target;
    };
};

var arrayIteration = {
    // `Array.prototype.forEach` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.foreach
    forEach: createMethod(0),
    // `Array.prototype.map` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.map
    map: createMethod(1),
    // `Array.prototype.filter` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.filter
    filter: createMethod(2),
    // `Array.prototype.some` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.some
    some: createMethod(3),
    // `Array.prototype.every` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.every
    every: createMethod(4),
    // `Array.prototype.find` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.find
    find: createMethod(5),
    // `Array.prototype.findIndex` method
    // https://tc39.github.io/ecma262/#sec-array.prototype.findIndex
    findIndex: createMethod(6)
};

var getBuiltIn = getBuiltIn$3;
var definePropertyModule$1 = objectDefineProperty;
var wellKnownSymbol$1 = wellKnownSymbol$e;
var DESCRIPTORS$1 = descriptors;

var SPECIES = wellKnownSymbol$1('species');

var setSpecies$1 = function(CONSTRUCTOR_NAME) {
    var Constructor = getBuiltIn(CONSTRUCTOR_NAME);
    var defineProperty = definePropertyModule$1.f;

    if (DESCRIPTORS$1 && Constructor && !Constructor[SPECIES]) {
        defineProperty(Constructor, SPECIES, {
            configurable: true,
            get: function() {
                return this;
            }
        });
    }
};

var isObject$1 = isObject$9;
var setPrototypeOf$1 = objectSetPrototypeOf;

// makes subclassing work correct for wrapped built-ins
var inheritIfRequired$1 = function($this, dummy, Wrapper) {
    var NewTarget, NewTargetPrototype;
    if (
        // it can work only with native `setPrototypeOf`
        setPrototypeOf$1 &&
        // we haven't completely correct pre-ES6 way for getting `new.target`, so use this
        typeof(NewTarget = dummy.constructor) == 'function' &&
        NewTarget !== Wrapper &&
        isObject$1(NewTargetPrototype = NewTarget.prototype) &&
        NewTargetPrototype !== Wrapper.prototype
    ) setPrototypeOf$1($this, NewTargetPrototype);
    return $this;
};

var $ = _export;
var global$3 = global$h;
var DESCRIPTORS = descriptors;
var TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS = typedArrayConstructorsRequireWrappers;
var ArrayBufferViewCore$4 = arrayBufferViewCore;
var ArrayBufferModule = arrayBuffer;
var anInstance = anInstance$2;
var createPropertyDescriptor = createPropertyDescriptor$4;
var createNonEnumerableProperty$1 = createNonEnumerableProperty$a;
var toLength$1 = toLength$9;
var toIndex = toIndex$2;
var toOffset$1 = toOffset$2;
var toPrimitive = toPrimitive$3;
var has = has$b;
var classof = classof$4;
var isObject = isObject$9;
var create = objectCreate;
var setPrototypeOf = objectSetPrototypeOf;
var getOwnPropertyNames = objectGetOwnPropertyNames.f;
var typedArrayFrom = typedArrayFrom$1;
var forEach = arrayIteration.forEach;
var setSpecies = setSpecies$1;
var definePropertyModule = objectDefineProperty;
var getOwnPropertyDescriptorModule = objectGetOwnPropertyDescriptor;
var InternalStateModule = internalState;
var inheritIfRequired = inheritIfRequired$1;

var getInternalState = InternalStateModule.get;
var setInternalState = InternalStateModule.set;
var nativeDefineProperty = definePropertyModule.f;
var nativeGetOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;
var round = Math.round;
var RangeError$1 = global$3.RangeError;
var ArrayBuffer$1 = ArrayBufferModule.ArrayBuffer;
var DataView$1 = ArrayBufferModule.DataView;
var NATIVE_ARRAY_BUFFER_VIEWS = ArrayBufferViewCore$4.NATIVE_ARRAY_BUFFER_VIEWS;
var TYPED_ARRAY_TAG = ArrayBufferViewCore$4.TYPED_ARRAY_TAG;
var TypedArray = ArrayBufferViewCore$4.TypedArray;
var TypedArrayPrototype = ArrayBufferViewCore$4.TypedArrayPrototype;
var aTypedArrayConstructor = ArrayBufferViewCore$4.aTypedArrayConstructor;
var isTypedArray = ArrayBufferViewCore$4.isTypedArray;
var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';
var WRONG_LENGTH = 'Wrong length';

var fromList = function(C, list) {
    var index = 0;
    var length = list.length;
    var result = new(aTypedArrayConstructor(C))(length);
    while (length > index) result[index] = list[index++];
    return result;
};

var addGetter = function(it, key) {
    nativeDefineProperty(it, key, {
        get: function() {
            return getInternalState(this)[key];
        }
    });
};

var isArrayBuffer = function(it) {
    var klass;
    return it instanceof ArrayBuffer$1 || (klass = classof(it)) == 'ArrayBuffer' || klass == 'SharedArrayBuffer';
};

var isTypedArrayIndex = function(target, key) {
    return isTypedArray(target) &&
        typeof key != 'symbol' &&
        key in target &&
        String(+key) == String(key);
};

var wrappedGetOwnPropertyDescriptor = function getOwnPropertyDescriptor(target, key) {
    return isTypedArrayIndex(target, key = toPrimitive(key, true)) ?
        createPropertyDescriptor(2, target[key]) :
        nativeGetOwnPropertyDescriptor(target, key);
};

var wrappedDefineProperty = function defineProperty(target, key, descriptor) {
    if (isTypedArrayIndex(target, key = toPrimitive(key, true)) &&
        isObject(descriptor) &&
        has(descriptor, 'value') &&
        !has(descriptor, 'get') &&
        !has(descriptor, 'set')
        // TODO: add validation descriptor w/o calling accessors
        &&
        !descriptor.configurable &&
        (!has(descriptor, 'writable') || descriptor.writable) &&
        (!has(descriptor, 'enumerable') || descriptor.enumerable)
    ) {
        target[key] = descriptor.value;
        return target;
    }
    return nativeDefineProperty(target, key, descriptor);
};

if (DESCRIPTORS) {
    if (!NATIVE_ARRAY_BUFFER_VIEWS) {
        getOwnPropertyDescriptorModule.f = wrappedGetOwnPropertyDescriptor;
        definePropertyModule.f = wrappedDefineProperty;
        addGetter(TypedArrayPrototype, 'buffer');
        addGetter(TypedArrayPrototype, 'byteOffset');
        addGetter(TypedArrayPrototype, 'byteLength');
        addGetter(TypedArrayPrototype, 'length');
    }

    $({
        target: 'Object',
        stat: true,
        forced: !NATIVE_ARRAY_BUFFER_VIEWS
    }, {
        getOwnPropertyDescriptor: wrappedGetOwnPropertyDescriptor,
        defineProperty: wrappedDefineProperty
    });

    typedArrayConstructor.exports = function(TYPE, wrapper, CLAMPED) {
        var BYTES = TYPE.match(/\d+$/)[0] / 8;
        var CONSTRUCTOR_NAME = TYPE + (CLAMPED ? 'Clamped' : '') + 'Array';
        var GETTER = 'get' + TYPE;
        var SETTER = 'set' + TYPE;
        var NativeTypedArrayConstructor = global$3[CONSTRUCTOR_NAME];
        var TypedArrayConstructor = NativeTypedArrayConstructor;
        var TypedArrayConstructorPrototype = TypedArrayConstructor && TypedArrayConstructor.prototype;
        var exported = {};

        var getter = function(that, index) {
            var data = getInternalState(that);
            return data.view[GETTER](index * BYTES + data.byteOffset, true);
        };

        var setter = function(that, index, value) {
            var data = getInternalState(that);
            if (CLAMPED) value = (value = round(value)) < 0 ? 0 : value > 0xFF ? 0xFF : value & 0xFF;
            data.view[SETTER](index * BYTES + data.byteOffset, value, true);
        };

        var addElement = function(that, index) {
            nativeDefineProperty(that, index, {
                get: function() {
                    return getter(this, index);
                },
                set: function(value) {
                    return setter(this, index, value);
                },
                enumerable: true
            });
        };

        if (!NATIVE_ARRAY_BUFFER_VIEWS) {
            TypedArrayConstructor = wrapper(function(that, data, offset, $length) {
                anInstance(that, TypedArrayConstructor, CONSTRUCTOR_NAME);
                var index = 0;
                var byteOffset = 0;
                var buffer, byteLength, length;
                if (!isObject(data)) {
                    length = toIndex(data);
                    byteLength = length * BYTES;
                    buffer = new ArrayBuffer$1(byteLength);
                } else if (isArrayBuffer(data)) {
                    buffer = data;
                    byteOffset = toOffset$1(offset, BYTES);
                    var $len = data.byteLength;
                    if ($length === undefined) {
                        if ($len % BYTES) throw RangeError$1(WRONG_LENGTH);
                        byteLength = $len - byteOffset;
                        if (byteLength < 0) throw RangeError$1(WRONG_LENGTH);
                    } else {
                        byteLength = toLength$1($length) * BYTES;
                        if (byteLength + byteOffset > $len) throw RangeError$1(WRONG_LENGTH);
                    }
                    length = byteLength / BYTES;
                } else if (isTypedArray(data)) {
                    return fromList(TypedArrayConstructor, data);
                } else {
                    return typedArrayFrom.call(TypedArrayConstructor, data);
                }
                setInternalState(that, {
                    buffer: buffer,
                    byteOffset: byteOffset,
                    byteLength: byteLength,
                    length: length,
                    view: new DataView$1(buffer)
                });
                while (index < length) addElement(that, index++);
            });

            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            TypedArrayConstructorPrototype = TypedArrayConstructor.prototype = create(TypedArrayPrototype);
        } else if (TYPED_ARRAYS_CONSTRUCTORS_REQUIRES_WRAPPERS) {
            TypedArrayConstructor = wrapper(function(dummy, data, typedArrayOffset, $length) {
                anInstance(dummy, TypedArrayConstructor, CONSTRUCTOR_NAME);
                return inheritIfRequired(function() {
                    if (!isObject(data)) return new NativeTypedArrayConstructor(toIndex(data));
                    if (isArrayBuffer(data)) return $length !== undefined ?
                        new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES), $length) :
                        typedArrayOffset !== undefined ?
                        new NativeTypedArrayConstructor(data, toOffset$1(typedArrayOffset, BYTES)) :
                        new NativeTypedArrayConstructor(data);
                    if (isTypedArray(data)) return fromList(TypedArrayConstructor, data);
                    return typedArrayFrom.call(TypedArrayConstructor, data);
                }(), dummy, TypedArrayConstructor);
            });

            if (setPrototypeOf) setPrototypeOf(TypedArrayConstructor, TypedArray);
            forEach(getOwnPropertyNames(NativeTypedArrayConstructor), function(key) {
                if (!(key in TypedArrayConstructor)) {
                    createNonEnumerableProperty$1(TypedArrayConstructor, key, NativeTypedArrayConstructor[key]);
                }
            });
            TypedArrayConstructor.prototype = TypedArrayConstructorPrototype;
        }

        if (TypedArrayConstructorPrototype.constructor !== TypedArrayConstructor) {
            createNonEnumerableProperty$1(TypedArrayConstructorPrototype, 'constructor', TypedArrayConstructor);
        }

        if (TYPED_ARRAY_TAG) {
            createNonEnumerableProperty$1(TypedArrayConstructorPrototype, TYPED_ARRAY_TAG, CONSTRUCTOR_NAME);
        }

        exported[CONSTRUCTOR_NAME] = TypedArrayConstructor;

        $({
            global: true,
            forced: TypedArrayConstructor != NativeTypedArrayConstructor,
            sham: !NATIVE_ARRAY_BUFFER_VIEWS
        }, exported);

        if (!(BYTES_PER_ELEMENT in TypedArrayConstructor)) {
            createNonEnumerableProperty$1(TypedArrayConstructor, BYTES_PER_ELEMENT, BYTES);
        }

        if (!(BYTES_PER_ELEMENT in TypedArrayConstructorPrototype)) {
            createNonEnumerableProperty$1(TypedArrayConstructorPrototype, BYTES_PER_ELEMENT, BYTES);
        }

        setSpecies(CONSTRUCTOR_NAME);
    };
} else typedArrayConstructor.exports = function() { /* empty */ };

var createTypedArrayConstructor = typedArrayConstructor.exports;

// `Uint8Array` constructor
// https://tc39.github.io/ecma262/#sec-typedarray-objects
createTypedArrayConstructor('Uint8', function(init) {
    return function Uint8Array(data, byteOffset, length) {
        return init(this, data, byteOffset, length);
    };
});

var ArrayBufferViewCore$3 = arrayBufferViewCore;
var $fill = arrayFill$1;

var aTypedArray$3 = ArrayBufferViewCore$3.aTypedArray;
var exportTypedArrayMethod$3 = ArrayBufferViewCore$3.exportTypedArrayMethod;

// `%TypedArray%.prototype.fill` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.fill
// eslint-disable-next-line no-unused-vars
exportTypedArrayMethod$3('fill', function fill(value /* , start, end */ ) {
    return $fill.apply(aTypedArray$3(this), arguments);
});

var ArrayBufferViewCore$2 = arrayBufferViewCore;
var toLength = toLength$9;
var toOffset = toOffset$2;
var toObject = toObject$6;
var fails$1 = fails$d;

var aTypedArray$2 = ArrayBufferViewCore$2.aTypedArray;
var exportTypedArrayMethod$2 = ArrayBufferViewCore$2.exportTypedArrayMethod;

var FORCED$1 = fails$1(function() {
    // eslint-disable-next-line no-undef
    new Int8Array(1).set({});
});

// `%TypedArray%.prototype.set` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.set
exportTypedArrayMethod$2('set', function set(arrayLike /* , offset */ ) {
    aTypedArray$2(this);
    var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);
    var length = this.length;
    var src = toObject(arrayLike);
    var len = toLength(src.length);
    var index = 0;
    if (len + offset > length) throw RangeError('Wrong length');
    while (index < len) this[offset + index] = src[index++];
}, FORCED$1);

var ArrayBufferViewCore$1 = arrayBufferViewCore;

var aTypedArray$1 = ArrayBufferViewCore$1.aTypedArray;
var exportTypedArrayMethod$1 = ArrayBufferViewCore$1.exportTypedArrayMethod;
var $sort = [].sort;

// `%TypedArray%.prototype.sort` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.sort
exportTypedArrayMethod$1('sort', function sort(comparefn) {
    return $sort.call(aTypedArray$1(this), comparefn);
});

var global$2 = global$h;
var ArrayBufferViewCore = arrayBufferViewCore;
var fails = fails$d;

var Int8Array$1 = global$2.Int8Array;
var aTypedArray = ArrayBufferViewCore.aTypedArray;
var exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;
var $toLocaleString = [].toLocaleString;
var $slice = [].slice;

// iOS Safari 6.x fails here
var TO_LOCALE_STRING_BUG = !!Int8Array$1 && fails(function() {
    $toLocaleString.call(new Int8Array$1(1));
});

var FORCED = fails(function() {
    return [1, 2].toLocaleString() != new Int8Array$1([1, 2]).toLocaleString();
}) || !fails(function() {
    Int8Array$1.prototype.toLocaleString.call([1, 2]);
});

// `%TypedArray%.prototype.toLocaleString` method
// https://tc39.github.io/ecma262/#sec-%typedarray%.prototype.tolocalestring
exportTypedArrayMethod('toLocaleString', function toLocaleString() {
    return $toLocaleString.apply(TO_LOCALE_STRING_BUG ? $slice.call(aTypedArray(this)) : aTypedArray(this), arguments);
}, FORCED);

// iterable DOM collections
// flag - `iterable` interface - 'entries', 'keys', 'values', 'forEach' methods
var domIterables = {
    CSSRuleList: 0,
    CSSStyleDeclaration: 0,
    CSSValueList: 0,
    ClientRectList: 0,
    DOMRectList: 0,
    DOMStringList: 0,
    DOMTokenList: 1,
    DataTransferItemList: 0,
    FileList: 0,
    HTMLAllCollection: 0,
    HTMLCollection: 0,
    HTMLFormElement: 0,
    HTMLSelectElement: 0,
    MediaList: 0,
    MimeTypeArray: 0,
    NamedNodeMap: 0,
    NodeList: 1,
    PaintRequestList: 0,
    Plugin: 0,
    PluginArray: 0,
    SVGLengthList: 0,
    SVGNumberList: 0,
    SVGPathSegList: 0,
    SVGPointList: 0,
    SVGStringList: 0,
    SVGTransformList: 0,
    SourceBufferList: 0,
    StyleSheetList: 0,
    TextTrackCueList: 0,
    TextTrackList: 0,
    TouchList: 0
};

var global$1 = global$h;
var DOMIterables = domIterables;
var ArrayIteratorMethods = es_array_iterator;
var createNonEnumerableProperty = createNonEnumerableProperty$a;
var wellKnownSymbol = wellKnownSymbol$e;

var ITERATOR = wellKnownSymbol('iterator');
var TO_STRING_TAG = wellKnownSymbol('toStringTag');
var ArrayValues = ArrayIteratorMethods.values;

for (var COLLECTION_NAME in DOMIterables) {
    var Collection = global$1[COLLECTION_NAME];
    var CollectionPrototype = Collection && Collection.prototype;
    if (CollectionPrototype) {
        // some Chrome versions have non-configurable methods on DOMTokenList
        if (CollectionPrototype[ITERATOR] !== ArrayValues) try {
            createNonEnumerableProperty(CollectionPrototype, ITERATOR, ArrayValues);
        } catch (error) {
            CollectionPrototype[ITERATOR] = ArrayValues;
        }
        if (!CollectionPrototype[TO_STRING_TAG]) {
            createNonEnumerableProperty(CollectionPrototype, TO_STRING_TAG, COLLECTION_NAME);
        }
        if (DOMIterables[COLLECTION_NAME])
            for (var METHOD_NAME in ArrayIteratorMethods) {
                // some Chrome versions have non-configurable methods on DOMTokenList
                if (CollectionPrototype[METHOD_NAME] !== ArrayIteratorMethods[METHOD_NAME]) try {
                    createNonEnumerableProperty(CollectionPrototype, METHOD_NAME, ArrayIteratorMethods[METHOD_NAME]);
                } catch (error) {
                    CollectionPrototype[METHOD_NAME] = ArrayIteratorMethods[METHOD_NAME];
                }
            }
    }
}

/******************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new(P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }

        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }

        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
    var e = new Error(message);
    return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;
};

var icon = "data:image/png;base64,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";

const STORAGE_ACCOUNT = "account";
const isInstalled = () => {
    return waitFor(() => !!window.dapp).catch(() => false);
};

function setupWalletState(storage) {
    return __awaiter(this, void 0, void 0, function*() {
        const account = yield storage.getItem(STORAGE_ACCOUNT);
        if (window.dapp) {
            const wallet = window.dapp;
            return {
                wallet,
                account: account ? account : undefined
            };
        }
        return {};
    });
}
const WelldoneWallet = ({
    options,
    store,
    emitter,
    logger,
    storage,
    provider
}) => __awaiter(void 0, void 0, void 0, function*() {
    const _state = yield setupWalletState(storage);
    const _getAccounts = () => __awaiter(void 0, void 0, void 0, function*() {
        if (_state.wallet) {
            const res = yield _state.wallet.request("near", {
                method: "dapp:accounts"
            });
            return res["near"] ? [res["near"].address, res["near"].pubKey] : [];
        }
        return [];
    });
    const _validateAccessKey = ({
        accountId,
        publicKey
    }) => __awaiter(void 0, void 0, void 0, function*() {
        logger.log("validateAccessKey", {
            accountId,
            publicKey
        });
        if (!_state.wallet) {
            throw new Error("Wallet is not installed");
        }
        const accessKey = yield _state.wallet.request("near", {
            method: "query",
            params: {
                request_type: "view_access_key",
                finality: "final",
                account_id: accountId,
                public_key: publicKey
            }
        });
        logger.log("validateAccessKey:accessKey", {
            accessKey
        });
        if (accessKey.permission !== "FullAccess") {
            throw new Error("Public key requires 'FullAccess' permission");
        }
        return accessKey;
    });
    const cleanup = () => {
        if (_state.account) {
            storage.removeItem(STORAGE_ACCOUNT);
            delete _state.account;
        }
    };
    const getAccounts = () => {
        return _state.account ? [{
            accountId: _state.account.accountId,
            publicKey: _state.account.publicKey
        }] : [];
    };
    const signOut = () => __awaiter(void 0, void 0, void 0, function*() {
        cleanup();
        emitter.emit("signedOut", null);
    });
    const setupEvents = () => {
        if (_state.wallet) {
            _state.wallet.on("dapp:accountsChanged", newAccountId => __awaiter(void 0, void 0, void 0, function*() {
                logger.log("onAccountChange", newAccountId);
                yield signOut();
            }));
            _state.wallet.on("dapp:chainChanged", rpc => __awaiter(void 0, void 0, void 0, function*() {
                logger.log("onNetworkChange", rpc);
                const networkId = rpc.split(":")[1] === "near" ? "mainnet" : "testnet";
                if (options.network.networkId !== networkId) {
                    yield signOut();
                    emitter.emit("networkChanged", {
                        networkId: networkId
                    });
                }
            }));
        }
    };
    const signer = {
        createKey: () => {
            throw new Error("Not implemented");
        },
        getPublicKey: accountId => __awaiter(void 0, void 0, void 0, function*() {
            const accounts = getAccounts();
            const account = accounts.find(a => a.accountId === accountId);
            if (!account) {
                throw new Error("Failed to find public key for account");
            }
            return nearAPI.utils.PublicKey.from(account.publicKey);
        }),
        signMessage: (message, accountId) => __awaiter(void 0, void 0, void 0, function*() {
            if (!_state.wallet) {
                throw new Error("Wallet is not installed");
            }
            const accounts = getAccounts();
            const account = accounts.find(a => a.accountId === accountId);
            if (!account) {
                throw new Error("Failed to find account for signing");
            }
            try {
                const tx = nearAPI.transactions.Transaction.decode(Buffer.from(message));
                const serializedTx = Buffer.from(tx.encode()).toString("hex");
                const signed = yield _state.wallet.request("near", {
                    method: "dapp:signTransaction",
                    params: ["0x" + serializedTx]
                });
                return {
                    signature: Buffer.from(signed[0].signature.substr(2), "hex"),
                    publicKey: nearAPI.utils.PublicKey.from(signed[0].publicKey)
                };
            } catch (err) {
                const signed = yield _state.wallet.request("near", {
                    method: "dapp:signMessage",
                    params: ["0x" + Buffer.from(message).toString("hex")]
                });
                return {
                    signature: Buffer.from(signed[0].signature.substr(2), "hex"),
                    publicKey: nearAPI.utils.PublicKey.from(signed[0].publicKey)
                };
            }
        })
    };
    const transformTransactions = transactions => {
        const accounts = getAccounts();
        const {
            contract
        } = store.getState();
        if (!accounts.length || !contract) {
            throw new Error("Wallet not signed in");
        }
        return transactions.map(transaction => {
            return {
                signerId: transaction.signerId || accounts[0].accountId,
                receiverId: transaction.receiverId || contract.contractId,
                actions: transaction.actions
            };
        });
    };
    return {
        signIn() {
            return __awaiter(this, void 0, void 0, function*() {
                const existingAccounts = getAccounts();
                if (existingAccounts.length) {
                    return existingAccounts;
                }
                if (_state.account) {
                    yield signOut();
                }
                const account = yield _getAccounts();
                const accessKey = yield _validateAccessKey({
                    accountId: account[0],
                    publicKey: account[1]
                });
                if (!accessKey) {
                    signOut();
                    throw new Error(`Public key (${account[1]}) is not registered with the account '${account[0]}'.`);
                }
                yield storage.setItem(STORAGE_ACCOUNT, {
                    accountId: account[0],
                    publicKey: account[1]
                });
                _state.account = {
                    accountId: account[0],
                    publicKey: account[1]
                };
                setupEvents();
                return getAccounts();
            });
        },
        getAccounts() {
            return __awaiter(this, void 0, void 0, function*() {
                return getAccounts();
            });
        },
        signOut,
        verifyOwner({
            message
        }) {
            return __awaiter(this, void 0, void 0, function*() {
                logger.log("verifyOwner", {
                    message
                });
                if (!_state.wallet) {
                    throw new Error("Wallet is not installed");
                }
                const account = _state.account;
                if (!account) {
                    throw new Error("Wallet not signed in");
                }
                const accountId = account.accountId;
                const pubKey = nearAPI.utils.PublicKey.fromString(account.publicKey);
                const block = yield provider.block({
                    finality: "final"
                });
                const data = {
                    accountId,
                    message,
                    blockId: block.header.hash,
                    publicKey: Buffer.from(pubKey.data).toString("base64"),
                    keyType: pubKey.keyType
                };
                const encoded = JSON.stringify(data);
                const signed = yield signer.signMessage(new Uint8Array(Buffer.from(encoded)), accountId);
                return Object.assign(Object.assign({}, data), {
                    signature: Buffer.from(signed.signature).toString("base64")
                });
            });
        },
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        signMessage(message) {
            return __awaiter(this, void 0, void 0, function*() {
                if (!_state.wallet) {
                    throw new Error("Wallet is not installed");
                }
                const account = yield _getAccounts();
                const accountId = account[0];
                if (!accountId) {
                    throw new Error("Failed to find account for signing");
                }
                const serializedTx = serializeNep413(message);
                const signed = yield _state.wallet.request("near", {
                    method: "dapp:signMessage",
                    params: ["0x" + serializedTx.toString("hex")]
                });
                const result = {
                    accountId,
                    publicKey: signed[0].publicKey,
                    signature: Buffer.from(signed[0].signature.substr(2), "hex").toString("base64")
                };
                if (message.state) {
                    return Object.assign(Object.assign({}, result), {
                        state: message.state
                    });
                }
                return result;
            });
        },
        signAndSendTransaction({
            signerId,
            receiverId,
            actions
        }) {
            return __awaiter(this, void 0, void 0, function*() {
                logger.log("signAndSendTransaction", {
                    signerId,
                    receiverId,
                    actions
                });
                const {
                    contract
                } = store.getState();
                const accounts = getAccounts();
                if (!accounts.length || !contract) {
                    throw new Error("Wallet not signed in");
                }
                const [signedTx] = yield signTransactions(transformTransactions([{
                    signerId,
                    receiverId,
                    actions
                }]), signer, options.network);
                return provider.sendTransaction(signedTx);
            });
        },
        signAndSendTransactions({
            transactions
        }) {
            return __awaiter(this, void 0, void 0, function*() {
                logger.log("signAndSendTransactions", {
                    transactions
                });
                const signedTxs = yield signTransactions(transformTransactions(transactions), signer, options.network);
                const results = [];
                for (let i = 0; i < signedTxs.length; i++) {
                    results.push(yield provider.sendTransaction(signedTxs[i]));
                }
                return results;
            });
        },
        importAccountsInSecureContext({
            accounts
        }) {
            return __awaiter(this, void 0, void 0, function*() {
                if (!_state.wallet) {
                    throw new Error("Wallet is not installed");
                }
                const privateKeys = [];
                // use batch import
                accounts.forEach(({
                    privateKey
                }) => {
                    if (privateKey.slice(0, 8) === "ed25519:") {
                        privateKeys.push(privateKey.slice(8));
                    } else {
                        privateKeys.push(privateKey);
                    }
                });
                const params = {
                    privateKey: privateKeys,
                    network: options.network.networkId
                };
                yield _state.wallet.request("near", {
                    method: "experimental:near:importPrivatekey",
                    params: [params]
                });
            });
        }
    };
});

function setupWelldoneWallet({
    iconUrl = icon,
    deprecated = false
} = {}) {
    return () => __awaiter(this, void 0, void 0, function*() {
        const mobile = isMobile();
        const isSupported = isCurrentBrowserSupported(["chrome", "edge-chromium", "opera"]);
        if (mobile || !isSupported) {
            return null;
        }
        const installed = yield isInstalled();
        return {
            id: "welldone-wallet",
            type: "injected",
            metadata: {
                name: "WELLDONE Wallet",
                description: "WELLDONE Wallet for Multichains",
                iconUrl,
                downloadUrl: "https://chrome.google.com/webstore/detail/welldone-wallet/bmkakpenjmcpfhhjadflneinmhboecjf",
                deprecated,
                available: installed
            },
            init: WelldoneWallet
        };
    });
}

export {
    setupWelldoneWallet
};