import {
    toHex as R
} from "viem";

function Y(x) {
    return x.message !== void 0
}
var j = 1,
    E = 2;
class H {
    t;
    n;
    key_label;
    metadata;
    constructor({
        t: x,
        n: F,
        key_label: B,
        permissions: J,
        ephPK: U
    }) {
        if (this.t = x, this.n = F, this.key_label = B, this.metadata = [], J) this.metadata.push({
            tag: j,
            value: J
        });
        if (U) this.metadata.push({
            tag: E,
            value: U
        })
    }
}
class V {
    authModule;
    threshold;
    totalNodes;
    wp_client;
    constructor(x, F, B, J) {
        if (F === 0) throw new Error("Threshold cannot be 0");
        this.threshold = F, this.totalNodes = B, this.authModule = J, this.wp_client = x
    }
    async authenticateAndCreateKey(x, F) {
        try {
            const B = new H({
                t: this.threshold,
                n: this.totalNodes,
                permissions: F,
                ephPK: R(x)
            });
            console.log("Generated Payload:", B);
            const J = (X) => this.authModule.authenticate({
                    setup: B,
                    challenge: X
                }),
                U = await this.wp_client.startKeygen({
                    setup: B,
                    signer: J
                });
            return console.log("Keygen response:", U), U
        } catch (B) {
            throw console.error(B), B
        }
    }
    async authenticateAndSign(x, F) {
        const B = {
                t: this.threshold,
                key_id: x,
                message: F
            },
            J = (X) => this.authModule.authenticate({
                setup: B,
                challenge: X
            }),
            U = await this.wp_client.startSigngen({
                setup: B,
                signer: J
            });
        return console.log("Sign response:", U), U
    }
}
import {
    toHex as z
} from "viem";
import {
    ed25519 as f
} from "@noble/curves/ed25519";
var k = function(x, F, B) {
    console.log("EPHKEY", B);
    const J = new H({
        t: x.t,
        n: x.n,
        key_label: x.key_label,
        permissions: void 0,
        ephPK: z(B)
    });
    return console.log("SETUP_NO_PERM", J), {
        types: {
            EIP712Domain: _,
            ...w
        },
        domain: I,
        primaryType: "Request",
        message: {
            setup: J,
            challenge: F
        }
    }
};
async function D({
    setup: x,
    user_id: F,
    challenge: B,
    browserWallet: J,
    ephPK: U,
    lifetime: X
}) {
    if (Y(x)) throw new Error("EOA auth cannot be used for Sign requests, please use EphAuth instead");
    const Z = k(x, B, U);
    console.log("typed request:"), console.log(JSON.stringify(Z, void 0, 4));
    const Q = await J.signTypedData(F, Z);
    console.log("User signed a request", Q);
    const $ = {
        eoa: F,
        ephPK: z(U),
        expiry: Math.floor(Date.now() / 1000) + X
    };
    return {
        credentials: {
            credentials: JSON.stringify($),
            method: "eoa",
            id: F
        },
        signature: Q
    }
}
async function N({
    setup: x,
    user_id: F,
    challenge: B,
    ephSK: J,
    ephPK: U
}) {
    const X = {
            setup: x,
            challenge: B
        },
        Z = new TextEncoder,
        Q = z(f.sign(Z.encode(JSON.stringify(X)), J));
    console.log("AUTH SIGNATURE by eph key", Q), console.log("User signed a request", Q);
    const $ = {
        eoa: F,
        ephPK: z(U),
        expiry: 0
    };
    return {
        credentials: {
            credentials: JSON.stringify($),
            method: "ephemeral",
            id: F
        },
        signature: Q
    }
}
var M = [{
        name: "tag",
        type: "uint16"
    }, {
        name: "value",
        type: "string"
    }],
    w = {
        Request: [{
            name: "setup",
            type: "KeygenSetupOpts"
        }, {
            name: "challenge",
            type: "string"
        }],
        KeygenSetupOpts: [{
            name: "t",
            type: "uint32"
        }, {
            name: "n",
            type: "uint32"
        }, {
            name: "metadata",
            type: "TaggedValue[]"
        }],
        TaggedValue: M
    },
    I = {
        name: "SilentShard authentication",
        version: "0.1.0"
    },
    _ = [{
        name: "name",
        type: "string"
    }, {
        name: "version",
        type: "string"
    }];
import {
    ed25519 as v
} from "@noble/curves/ed25519";
var q;
(function(B) {
    B[B["EOA"] = 0] = "EOA";
    B[B["NONE"] = 1] = "NONE"
})(q || (q = {}));
class W {
    userId;
    browserWallet;
    ephPK;
    lifetime;
    constructor(x, F, B, J = 3600) {
        this.userId = x, this.browserWallet = F, this.ephPK = B, this.lifetime = J
    }
    async authenticate({
        setup: x,
        challenge: F
    }) {
        return await D({
            setup: x,
            user_id: this.userId,
            challenge: F,
            browserWallet: this.browserWallet,
            ephPK: this.ephPK,
            lifetime: this.lifetime
        })
    }
}
class C {
    userId;
    ephSK;
    ephPK;
    constructor(x, F) {
        this.userId = x, this.ephSK = F, this.ephPK = v.getPublicKey(this.ephSK)
    }
    async authenticate({
        setup: x,
        challenge: F
    }) {
        return await N({
            setup: x,
            user_id: this.userId,
            challenge: F,
            ephSK: this.ephSK,
            ephPK: this.ephPK
        })
    }
}
var T = (x) => btoa(String.fromCodePoint.apply(null, Array.from(x)));
var L;
(function(U) {
    U[U["initiated"] = 0] = "initiated";
    U[U["waitingForSign"] = 1] = "waitingForSign";
    U[U["waitingForResult"] = 2] = "waitingForResult";
    U[U["finished"] = 3] = "finished"
})(L || (L = {}));
class O {
    walletProviderId;
    walletProviderUrl;
    constructor(x) {
        this.walletProviderId = x.walletProviderId, this.walletProviderUrl = x.walletProviderUrl
    }
    getWalletId() {
        return this.walletProviderId
    }
    async startKeygen({
        setup: x,
        signer: F
    }) {
        return this.connect(x, F).then((B) => {
            const J = B.split(":"),
                U = J[1].split("=")[1],
                X = J[0].split("=")[1];
            return {
                publicKey: U,
                keyId: X
            }
        })
    }
    async startSigngen({
        setup: x,
        signer: F
    }) {
        return this.connect(x, F).then((B) => {
            const J = B.split(":"),
                U = J[0].split("=")[1],
                X = J[1].split("=")[1];
            return {
                sign: U,
                recid: parseInt(X)
            }
        })
    }
    connect(x, F) {
        return new Promise((B, J) => {
            let U = L.initiated,
                X;
            if (Y(x)) X = "signgen", x.message = T((new TextEncoder()).encode(x.message));
            else X = "keygen";
            const Z = new WebSocket(`${this.walletProviderUrl}/${X}`);
            Z.addEventListener("open", (Q) => {
                switch (console.log(`Connection opened in state ${U} with event ${JSON.stringify(Q,void 0,"\t")}`), U) {
                    case L.initiated:
                        U = L.waitingForSign, console.log(`Sending setup: ${JSON.stringify(x)}`), Z.send(JSON.stringify(x));
                        break;
                    case L.waitingForSign:
                    case L.waitingForResult:
                        U = L.finished, J("Incorrect protocol state");
                        break;
                    case L.finished:
                        break
                }
            }), Z.addEventListener("message", async (Q) => {
                switch (console.log(`Connection message in state ${U} with event ${JSON.stringify(Q,void 0,"\t")}`), U) {
                    case L.initiated:
                        U = L.finished, J("Incorrect protocol state");
                        break;
                    case L.waitingForSign:
                        {
                            U = L.waitingForResult;
                            const $ = await F(Q.data);console.log(`Sending signature: ${JSON.stringify($)}`),
                            Z.send(JSON.stringify($));
                            break
                        }
                    case L.waitingForResult:
                        U = L.finished, Z.close(), B(Q.data);
                        break;
                    case L.finished:
                        break
                }
            }), Z.addEventListener("error", (Q) => {
                if (console.log(`Connection error in state ${U} with event ${JSON.stringify(Q,void 0,"\t")}`), U != L.finished) U = L.finished, J("Incorrect protocol state")
            }), Z.addEventListener("close", (Q) => {
                if (console.log(`Connection closed in state ${U} with event ${JSON.stringify(Q,void 0,"\t")}`), U != L.finished) U = L.finished, J("Incorrect protocol state")
            })
        })
    }
}
import * as G from "viem";
import {
    publicKeyToAddress as A,
    toAccount as t
} from "viem/accounts";
import {
    secp256k1 as b
} from "@noble/curves/secp256k1";

function m(x) {
    if (x.startsWith("0x")) x = x.slice(2);
    if (x.startsWith("04")) return A(`0x${x} `);
    else if (x.startsWith("02") || x.startsWith("03")) {
        const F = b.ProjectivePoint.fromHex(x).toHex(!1);
        return A(`0x${F}`)
    } else throw new Error("Invalid public key")
}
export {
    m as computeAddress, O as WalletProviderServiceClient, V as NetworkSigner, C as EphAuth, W as EOAAuth, q as AuthMethod
};