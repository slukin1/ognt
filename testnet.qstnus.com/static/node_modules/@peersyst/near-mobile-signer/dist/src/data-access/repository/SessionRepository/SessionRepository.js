"use strict";
var __awaiter = (this && this.__awaiter) || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new(P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }

        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }

        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.SessionRepository = void 0;
const WindowLocalStorageRepository_1 = require("../common/WindowLocalStorageRepository");
const index_1 = require("../../errors/index");
const near_api_js_1 = require("near-api-js");
class SessionRepository extends WindowLocalStorageRepository_1.WindowLocalStorageRepository {
    constructor() {
        super("session");
        this.loadSessionState();
    }
    loadSessionState() {
        return __awaiter(this, void 0, void 0, function*() {
            const currentSessionState = yield this.get();
            if (!currentSessionState)
                yield this.set({
                    mainnet: {
                        activeAccount: null,
                        accounts: {}
                    },
                    testnet: {
                        activeAccount: null,
                        accounts: {}
                    }
                });
        });
    }
    getKey(network, accountId) {
        var _a;
        return __awaiter(this, void 0, void 0, function*() {
            const sessionState = yield this.get();
            const privateKey = (_a = sessionState[network]) === null || _a === void 0 ? void 0 : _a.accounts[accountId];
            if (!privateKey)
                throw new Error(index_1.RepositoryErrorCodes.ACCOUNT_KEY_NOT_FOUND);
            return near_api_js_1.KeyPair.fromString(privateKey);
        });
    }
    setKey(network, accountId, accessKey) {
        return __awaiter(this, void 0, void 0, function*() {
            const sessionState = yield this.get();
            sessionState[network].accounts[accountId] = accessKey.toString();
            yield this.set(sessionState);
        });
    }
    removeKey(network, accountId) {
        return __awaiter(this, void 0, void 0, function*() {
            const sessionState = yield this.get();
            if (sessionState[network].activeAccount === accountId)
                sessionState[network].activeAccount = null;
            delete sessionState[network].accounts[accountId];
            yield this.set(sessionState);
        });
    }
    getActiveAccount(network) {
        return __awaiter(this, void 0, void 0, function*() {
            const sessionState = yield this.get();
            return sessionState[network].activeAccount;
        });
    }
    setActiveAccount(network, accountId) {
        return __awaiter(this, void 0, void 0, function*() {
            const sessionState = yield this.get();
            const accountExists = Object.keys(sessionState[network].accounts).includes(accountId);
            if (!accountExists)
                throw new Error(index_1.RepositoryErrorCodes.INVALID_ACCOUNT_ID);
            sessionState[network].activeAccount = accountId;
            yield this.set(sessionState);
        });
    }
    getAccounts(network) {
        return __awaiter(this, void 0, void 0, function*() {
            const sessionState = yield this.get();
            const accounts = sessionState[network].accounts;
            return Object.keys(accounts);
        });
    }
    getNetworks() {
        return __awaiter(this, void 0, void 0, function*() {
            const sessionState = yield this.get();
            return Object.keys(sessionState);
        });
    }
    clear() {
        return __awaiter(this, void 0, void 0, function*() {
            yield this.clear();
        });
    }
}
exports.SessionRepository = SessionRepository;