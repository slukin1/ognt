"use strict";
var __awaiter = (this && this.__awaiter) || function(thisArg, _arguments, P, generator) {
    function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
            resolve(value);
        });
    }
    return new(P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
            try {
                step(generator.next(value));
            } catch (e) {
                reject(e);
            }
        }

        function rejected(value) {
            try {
                step(generator["throw"](value));
            } catch (e) {
                reject(e);
            }
        }

        function step(result) {
            result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.NearMobileWallet = void 0;
const near_api_js_1 = require("near-api-js");
const providers_1 = require("near-api-js/lib/providers");
const WidgetStrategy_1 = require("./strategies/WidgetStrategy");
const NearMobileSignerProxy_1 = require("./providers/NearMobileSignerProxy");
const SignerRequestStatus_1 = require("../data-access/api/models/models/SignerRequestStatus");
const isValidAccessKey_1 = require("../common/utils/isValidAccessKey");
const createAction_1 = require("../common/utils/createAction");
const errors_1 = require("./errors");
const data_access_1 = require("../data-access");
const verify_signature_1 = require("./utils/verify-signature/verify-signature");
const index_1 = require("../data-access/errors/index");
class NearMobileWallet {
    handleRequestStatus(status) {
        var _a, _b, _c, _d;
        if (status === SignerRequestStatus_1.SignerRequestStatus.APPROVED) {
            (_b = (_a = this.defaultStrategy).onApproved) === null || _b === void 0 ? void 0 : _b.call(_a);
        } else if (status === SignerRequestStatus_1.SignerRequestStatus.REJECTED) {
            (_d = (_c = this.defaultStrategy).onError) === null || _d === void 0 ? void 0 : _d.call(_c);
        }
    }
    loadConnection(nodeUrl, network) {
        const signer = new near_api_js_1.InMemorySigner(this.sessionRepository);
        const rpc = new providers_1.JsonRpcProvider({
            url: nodeUrl !== null && nodeUrl !== void 0 ? nodeUrl : `https://rpc.${network}.near.org`
        });
        this.connection = near_api_js_1.Connection.fromConfig({
            jsvmAccountId: `jsvm.${network}`,
            provider: rpc,
            network,
            signer,
        });
    }
    retryTransaction({
        requests
    }) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const {
                    id,
                    network,
                    requests: transactions
                } = yield this.defaultProvider.createRequest(this.network, requests, this.dAppMetadata);
                (_b = (_a = this.defaultStrategy).onRequested) === null || _b === void 0 ? void 0 : _b.call(_a, id, {
                    network: network,
                    request: transactions
                });
                const {
                    status
                } = yield this.defaultProvider.awaitActionSignatureResolution(id);
                this.handleRequestStatus(status);
                const {
                    signerAccountId,
                    txHash
                } = yield this.defaultProvider.getRequest(id);
                if (!signerAccountId || !txHash)
                    throw new Error(errors_1.WalletErrors.REQUEST_NOT_SIGNED);
                if (txHash.length === 1)
                    return yield this.rpc.txStatus(txHash[0], signerAccountId, 'EXECUTED_OPTIMISTIC');
                else
                    throw new Error(errors_1.WalletErrors.OPERATION_FAILED);
            } catch (e) {
                (_d = (_c = this.defaultStrategy).onError) === null || _d === void 0 ? void 0 : _d.call(_c);
                throw new Error(e);
            }
        });
    }
    constructor({
        nodeUrl,
        network = "testnet",
        sessionRepository = new data_access_1.SessionRepository(),
        metadata,
    } = {}) {
        this.network = network;
        this.sessionRepository = sessionRepository;
        this.defaultStrategy = new WidgetStrategy_1.WidgetStrategy();
        this.defaultProvider = new NearMobileSignerProxy_1.NearMobileSignerProxy();
        this.dAppMetadata = metadata;
        this.loadConnection(nodeUrl, network);
    }
    get rpc() {
        return this.connection.provider;
    }
    get signer() {
        return this.connection.signer;
    }
    get networkId() {
        return this.connection.networkId;
    }
    getAccounts() {
        return __awaiter(this, void 0, void 0, function*() {
            return this.sessionRepository.getAccounts(this.network);
        });
    }
    isSignedIn(accountId) {
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const activeAccount = yield this.sessionRepository.getActiveAccount(this.network);
                if ((accountId && activeAccount !== accountId) || activeAccount === null)
                    return false;
                const storedAccessKey = yield this.sessionRepository.getKey(this.network, activeAccount);
                if (storedAccessKey === null)
                    throw new Error(index_1.RepositoryErrorCodes.ACCOUNT_KEY_NOT_FOUND);
                const account = yield this.account(activeAccount);
                const accessKeys = yield account.getAccessKeys();
                const accessKey = accessKeys.find((key) => key.public_key === storedAccessKey.getPublicKey().toString());
                return accessKey !== undefined;
            } catch (e) {
                if (e.message === index_1.RepositoryErrorCodes.ACCOUNT_KEY_NOT_FOUND)
                    return false;
                else
                    throw new Error(e);
            }
        });
    }
    signOut() {
        return __awaiter(this, void 0, void 0, function*() {
            const isActiveAccountSignedIn = yield this.isSignedIn();
            const activeAccount = yield this.sessionRepository.getActiveAccount(this.network);
            if (!isActiveAccountSignedIn) {
                yield this.sessionRepository.removeKey(this.network, activeAccount);
                return;
            }
            const activeAccountKey = yield this.sessionRepository.getKey(this.network, activeAccount);
            if (activeAccountKey === null)
                throw new Error(errors_1.WalletErrors.NO_ACCOUNT_LOCAL_KEY);
            const publicKey = activeAccountKey.getPublicKey().toString();
            try {
                yield this.silentSignAndSendTransaction({
                    signerId: activeAccount,
                    receiverId: activeAccount,
                    actions: [{
                        type: "DeleteKey",
                        params: {
                            publicKey
                        }
                    }],
                });
                yield this.sessionRepository.removeKey(this.network, activeAccount);
            } catch (e) {
                yield this.retryTransaction({
                    requests: [{
                        actions: [{
                            type: "DeleteKey",
                            params: {
                                publicKey
                            }
                        }],
                        signerId: activeAccount,
                        receiverId: activeAccount
                    }],
                });
                yield this.sessionRepository.removeKey(this.network, activeAccount);
            }
        });
    }
    signIn({
        contractId,
        allowance,
        methodNames = []
    }) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const accessKey = near_api_js_1.KeyPair.fromRandom("ed25519");
                const permission = {
                    receiverId: contractId,
                    methodNames,
                    allowance
                };
                const signInTransaction = [{
                    actions: [{
                        type: "AddKey",
                        params: {
                            publicKey: accessKey.getPublicKey().toString(),
                            accessKey: {
                                permission
                            }
                        }
                    }]
                }, ];
                const {
                    id,
                    network,
                    requests
                } = yield this.defaultProvider.createRequest(this.network, signInTransaction, this.dAppMetadata);
                const handleClose = () => __awaiter(this, void 0, void 0, function*() {
                    return yield this.defaultProvider.rejectSignerRequest(id);
                });
                (_b = (_a = this.defaultStrategy).onRequested) === null || _b === void 0 ? void 0 : _b.call(_a, id, {
                    network: network,
                    request: requests
                }, handleClose);
                const {
                    status
                } = yield this.defaultProvider.awaitActionSignatureResolution(id);
                this.handleRequestStatus(status);
                const {
                    signerAccountId
                } = yield this.defaultProvider.getRequest(id);
                if (!signerAccountId)
                    throw new Error(errors_1.WalletErrors.REQUEST_NOT_SIGNED);
                yield this.sessionRepository.setKey(this.network, signerAccountId, accessKey);
                yield this.sessionRepository.setActiveAccount(this.network, signerAccountId);
                return signerAccountId;
            } catch (error) {
                throw new Error(error);
            }
        });
    }
    account(id) {
        return __awaiter(this, void 0, void 0, function*() {
            const activeAccount = id !== null && id !== void 0 ? id : (yield this.sessionRepository.getActiveAccount(this.network));
            if (activeAccount === null)
                throw new Error(errors_1.WalletErrors.NO_ACTIVE_ACCOUNT);
            return new near_api_js_1.Account(this.connection, activeAccount);
        });
    }
    silentSignAndSendTransaction({
        signerId,
        receiverId,
        actions,
    }) {
        return __awaiter(this, void 0, void 0, function*() {
            const account = yield this.account(signerId);
            const accountLocalKey = yield this.sessionRepository.getKey(this.network, account.accountId);
            if (accountLocalKey === null)
                throw new Error(errors_1.WalletErrors.NO_ACTIVE_ACCOUNT);
            const isSignerSignedIn = yield this.isSignedIn(account.accountId);
            if (!isSignerSignedIn) {
                throw new Error(errors_1.WalletErrors.NO_ACTIVE_ACCOUNT);
            }
            const publicLocalKey = accountLocalKey.getPublicKey().toString();
            const accessKey = yield account.getAccessKeys();
            const request = {
                receiverId,
                actions
            };
            const containsValidAccessKey = accessKey.some((key) => (0, isValidAccessKey_1.isValidAccessKey)(account.accountId, key, publicLocalKey, request));
            if (!containsValidAccessKey)
                throw new Error(errors_1.WalletErrors.INVALID_ACCESS_KEY);
            return yield account.signAndSendTransaction({
                actions: actions.map((action) => (0, createAction_1.createAction)(action)),
                receiverId: receiverId !== null && receiverId !== void 0 ? receiverId : account.accountId,
            });
        });
    }
    signAndSendTransaction({
        signerId,
        receiverId,
        actions
    }) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const isSignerSignedIn = yield this.isSignedIn(signerId);
                if (!isSignerSignedIn) {
                    yield this.sessionRepository.removeKey(this.network, signerId);
                    throw new Error(errors_1.WalletErrors.NO_ACTIVE_ACCOUNT);
                }
                const result = yield this.silentSignAndSendTransaction({
                    signerId,
                    receiverId,
                    actions
                });
                (_b = (_a = this.defaultStrategy).onSuccess) === null || _b === void 0 ? void 0 : _b.call(_a);
                return result;
            } catch (error) {
                if (error.message === errors_1.WalletErrors.NO_ACTIVE_ACCOUNT)
                    throw new Error(error);
                else
                    return yield this.retryTransaction({
                        requests: [{
                            actions,
                            receiverId,
                            signerId
                        }]
                    });
            }
        });
    }
    signAndSendTransactions({
        transactions
    }) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function*() {
            try {
                const isAccountSignedIn = yield this.isSignedIn(transactions[0].signerId);
                if (!isAccountSignedIn) {
                    yield this.sessionRepository.removeKey(this.network, transactions[0].signerId);
                    throw new Error(errors_1.WalletErrors.NO_ACTIVE_ACCOUNT);
                }
                const {
                    id,
                    network,
                    requests
                } = yield this.defaultProvider.createRequest(this.network, transactions, this.dAppMetadata);
                (_b = (_a = this.defaultStrategy).onRequested) === null || _b === void 0 ? void 0 : _b.call(_a, id, {
                    network: network,
                    request: requests
                });
                const {
                    status
                } = yield this.defaultProvider.awaitActionSignatureResolution(id);
                this.handleRequestStatus(status);
                const {
                    signerAccountId,
                    txHash
                } = yield this.defaultProvider.getRequest(id);
                if (!signerAccountId || !txHash)
                    throw new Error(errors_1.WalletErrors.REQUEST_NOT_SIGNED);
                const result = [];
                for (const hash of txHash) {
                    const status = yield this.rpc.txStatus(hash, signerAccountId, 'EXECUTED_OPTIMISTIC');
                    result.push(status);
                }
                return result;
            } catch (error) {
                (_d = (_c = this.defaultStrategy).onError) === null || _d === void 0 ? void 0 : _d.call(_c);
                throw new Error(error);
            }
        });
    }
    signMessage({
        message,
        receiver,
        nonce,
        callbackUrl
    }) {
        var _a, _b, _c, _d, _e, _f;
        return __awaiter(this, void 0, void 0, function*() {
            const {
                id
            } = yield this.defaultProvider.createSignMessage(this.network, message, receiver, nonce, callbackUrl, this.dAppMetadata);
            (_b = (_a = this.defaultStrategy).onRequested) === null || _b === void 0 ? void 0 : _b.call(_a, id, {
                network: this.network,
                message,
                receiver,
                nonce,
                callbackUrl
            });
            const {
                response,
                status
            } = yield this.defaultProvider.awaitMessageSignatureResolution(id);
            this.handleRequestStatus(status);
            if (!response && status !== SignerRequestStatus_1.SignerRequestStatus.APPROVED)
                throw new Error(errors_1.WalletErrors.NO_SIGNATURE);
            try {
                const {
                    publicKey,
                    signature,
                    accountId
                } = response;
                const isValidSignature = (0, verify_signature_1.verifySignature)({
                    publicKey,
                    signature,
                    message,
                    nonce: Buffer.from(nonce),
                    recipient: receiver
                });
                if (!isValidSignature)
                    throw new Error(errors_1.WalletErrors.INVALID_SIGNATURE);
                const account = yield this.account(accountId);
                const keys = yield account.getAccessKeys();
                const isFullAccess = keys.some((k) => {
                    if (k.public_key !== publicKey)
                        return false;
                    if (k.access_key.permission !== "FullAccess")
                        return false;
                    return true;
                });
                if (!isFullAccess)
                    throw Error(errors_1.WalletErrors.INVALID_ACCESS_KEY);
                (_d = (_c = this.defaultStrategy).onSuccess) === null || _d === void 0 ? void 0 : _d.call(_c);
                return {
                    signature,
                    publicKey,
                    message,
                    accountId,
                    receiver,
                    nonce,
                    callbackUrl,
                };
            } catch (error) {
                (_f = (_e = this.defaultStrategy).onError) === null || _f === void 0 ? void 0 : _f.call(_e);
                throw new Error(error);
            }
        });
    }
}
exports.NearMobileWallet = NearMobileWallet;